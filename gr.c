

#define COLORS_NUM  16

//REGULAR COLORS
#define BLACK       RGB(0,0,0)
#define BLUE        RGB(0,0,170)
#define GREEN    	RGB(0,170,0)
#define CYAN        RGB(0,170,170)
#define RED         RGB(170,0,0)
#define PURPLE      RGB(170,0,170)
#define BROWN       RGB(170,85,0)
#define LTGRAY      RGB(170,170,170)
#define DKGRAY      RGB(85,85,85)
#define LTBLUE      RGB(0,0,255)
#define LTGREEN     RGB(0,255,0)
#define LTCYAN      RGB(0,255,255)
#define LTRED       RGB(255,0,0)
#define LTPURPLE    RGB(255,0,255)
#define YELLOW      RGB(255,255,0)
#define WHITE       RGB(255,255,255)



#define DKBLACK     RGB(2,2,2) //For drawing
#define LPURPLE     RGB(170,43,170)
#define LLTGREEN    RGB(0,254,0)
#define MYCOLOR1    RGB(22,22,22)//RGB(1,1,1)

//DARK COLORS
#define DKRBLACK       RGB(0,0,0)
#define DKRBLUE        RGB(0,0,32)
#define DKRGREEN       RGB(0,32,0)
#define DKRCYAN        RGB(0,32,32)
#define DKRRED         RGB(32,0,0)
#define DKRPURPLE      RGB(32,0,32)
#define DKRBROWN       RGB(32,16,0)
#define DKRLTGRAY      RGB(48,48,48)
#define DKRDKGRAY      RGB(32,32,32)
#define DKRLTBLUE      RGB(0,0,48)
#define DKRLTGREEN     RGB(0,48,0)
#define DKRLTCYAN      RGB(0,48,48)
#define DKRLTRED       RGB(48,0,0)
#define DKRLTPURPLE    RGB(48,0,48)
#define DKRYELLOW      RGB(48,48,0)
#define DKRWHITE       RGB(255,255,255)


//LIGHT COLORS
#define LTRBLACK       RGB(0,0,0)
#define LTRBLUE        RGB(85,85,170)
#define LTRGREEN       RGB(85,170,85)
#define LTRCYAN        RGB(85,170,170)
#define LTRRED         RGB(170,85,85)
#define LTRPURPLE      RGB(170,85,170)
#define LTRBROWN       RGB(170,170,85)
#define LTRLTGRAY      RGB(170,170,170)
#define LTRDKGRAY      RGB(85,85,85)
#define LTRLTBLUE      RGB(170,170,255)
#define LTRLTGREEN     RGB(170,255,170)
#define LTRLTCYAN      RGB(170,255,255)
#define LTRLTRED       RGB(255,170,170)
#define LTRLTPURPLE    RGB(255,170,255)
#define LTRYELLOW      RGB(255,255,170)
#define LTRWHITE       RGB(255,255,255)


//LIGHTER COLORS
#define LTR2BLACK       RGB(0,0,0)
#define LTR2BLUE        RGB(149,149,170)
#define LTR2GREEN       RGB(149,170,149)
#define LTR2CYAN        RGB(149,170,170)
#define LTR2RED         RGB(170,149,149)
#define LTR2PURPLE      RGB(170,149,170)
#define LTR2BROWN       RGB(170,160,149)

#define LTR2LTGRAY      RGB(224,224,224)
#define LTR2DKGRAY      RGB(170,170,170)

#define LTR2LTBLUE      RGB(224,224,255)
#define LTR2LTGREEN     RGB(224,255,224)
#define LTR2LTCYAN      RGB(224,255,255)
#define LTR2LTRED       RGB(255,224,224)
#define LTR2LTPURPLE    RGB(255,224,255)
#define LTR2YELLOW      RGB(255,255,224)
#define LTR2WHITE       RGB(255,255,255)



//#define IDI_MYICON  1000

/*int color_arr[COLORS_NUM]={
BLACK, //0
BLUE, //1
GREEN, //2
CYAN, //3
RED, //4
PURPLE, //5
BROWN, //6
LTGRAY, //7
DKGRAY, //8
LTBLUE, //9
LTGREEN, //10
LTCYAN, //11
LTRED, //12
LTPURPLE, //13
YELLOW, //14
WHITE //15
};*/

/*int draw_color_arr[COLORS_NUM]={
DKBLACK, //0
BLUE, //1
GREEN, //2
CYAN, //3
RED, //4
PURPLE, //5
BROWN, //6
LTGRAY, //7
DKGRAY, //8
LTBLUE, //9
LLTGREEN, //10
LTCYAN, //11
LTRED, //12
LTPURPLE, //13
YELLOW, //14
WHITE //15
};*/


/*
int draw_darker_color_arr[COLORS_NUM]={
DKRBLACK, //0
DKRBLUE, //1
DKRGREEN, //2
DKRCYAN, //3
DKRRED, //4
DKRPURPLE, //5
DKRBROWN, //6
DKRLTGRAY, //7
DKRDKGRAY, //8
DKRLTBLUE, //9
DKRLTGREEN, //10
DKRLTCYAN, //11
DKRLTRED, //12
DKRLTPURPLE, //13
DKRYELLOW, //14
DKRWHITE //15
};



int draw_lighter_color_arr[COLORS_NUM]={
LTRBLACK, //0
LTRBLUE, //1
LTRGREEN, //2
LTRCYAN, //3
LTRRED, //4
LTRPURPLE, //5
LTRBROWN, //6
LTRLTGRAY, //7
LTRDKGRAY, //8
LTRLTBLUE, //9
LTRLTGREEN, //10
LTRLTCYAN, //11
LTRLTRED, //12
LTRLTPURPLE, //13
LTRYELLOW, //14
LTRWHITE //15
};

int draw_lighter_color_arr2[COLORS_NUM]={
LTR2BLACK, //0
LTR2BLUE, //1
LTR2GREEN, //2
LTR2CYAN, //3
LTR2RED, //4
LTR2PURPLE, //5
LTR2BROWN, //6
LTR2LTGRAY, //7
LTR2DKGRAY, //8
LTR2LTBLUE, //9
LTR2LTGREEN, //10
LTR2LTCYAN, //11
LTR2LTRED, //12
LTR2LTPURPLE, //13
LTR2YELLOW, //14
LTR2WHITE //15
};



int draw_lighter_color_arr3[COLORS_NUM]={
LTR2WHITE, //0
LTR2LTBLUE, //9
LTR2LTGREEN, //10
LTR2LTCYAN, //11
LTR2LTRED, //12
LTR2LTPURPLE, //13
LTR2YELLOW, //14
LTR2LTGRAY, //7
LTR2DKGRAY, //8
LTR2LTBLUE, //9
LTR2LTGREEN, //10
LTR2LTCYAN, //11
LTR2LTRED, //12
LTR2LTPURPLE, //13
LTR2YELLOW, //14
LTR2WHITE //15
};*/


int Highlight(bool predicate,int color1, int color2)
{
  if (predicate)
    return color2;
  return color1;
}



RGBQUAD rgbColorsNoir[256];
void Init8BitRGBColorsNoir(RGBQUAD *rgbColors)
{
  int calc;
  int index_range;
  for (int i = 0; i < 256; i++) {
    calc = i/16;
    //green->ltpurple
    if (calc==0 || calc==15) {
      rgbColors[i].rgbRed = i;
      rgbColors[i].rgbGreen = i;
      rgbColors[i].rgbBlue = i;
    } else {
      rgbColors[i].rgbRed = 255-i;
      rgbColors[i].rgbGreen = 255-i;
      rgbColors[i].rgbBlue = 255-i;
    }
  }
}

/*typedef struct SPRITE
{
  int width,height;
  HBITMAP sprite_mask;
  HBITMAP sprite_paint;
} ASPRITE;*/

//HBITMAP ReplaceColor(int num, COLOR* oldColor, COLOR* newColor, HBITMAP hBitmap)
//https://gamedev.net/forums/topic/267754-win32-replacing-color-in-a-bitmap/267754/

RGBQUAD rgbColorsDefault[256];
void Init8BitRGBColorsDefault(RGBQUAD *rgbColors)
{
  int calc;
  for(int i=0; i<256; i++) {
    calc=i/16;
    double index_range = i-16*calc+1; //0 to 15 //0,1, 2,3, 4,5, 6,7      8,9, 10,11, 12,13, 14,15
    switch (calc) {
      case 0: //BLACK
        rgbColors[i].rgbRed = i/2;
        rgbColors[i].rgbGreen = i/2;
        rgbColors[i].rgbBlue = i/2;
        rgbColors[i].rgbReserved = 0;
        break;
      case 1: //BLUE
        if (index_range<=8) { //1->7 Darker values, 8 is true value
          rgbColors[i].rgbRed = 0;
          rgbColors[i].rgbGreen = 0;
          rgbColors[i].rgbBlue = ceil(index_range*170/8);
        } else { //9->16 Lighter values
          if (index_range==16) { //1->7 Darker values, 8 is true value
            rgbColors[i].rgbRed = 160;
            rgbColors[i].rgbGreen = 160;
          } else {
            rgbColors[i].rgbRed = ceil((index_range-8)*170/8);
            rgbColors[i].rgbGreen = ceil((index_range-8)*170/8);
          }
          rgbColors[i].rgbBlue = 170;
        }
        rgbColors[i].rgbReserved = 0;
        break;
      case 2: //GREEN
        if (index_range<=8) { //1->7 Darker values, 8 is true value
          rgbColors[i].rgbRed = 0;
          rgbColors[i].rgbGreen = ceil(index_range*170/8);
          rgbColors[i].rgbBlue = 0;
        } else { //9->16 Lighter values
          rgbColors[i].rgbGreen = 170;
          if (index_range==16) {
            rgbColors[i].rgbRed = 160;
            rgbColors[i].rgbBlue = 160;
          } else {
            rgbColors[i].rgbRed = ceil((index_range-8)*170/8);
            rgbColors[i].rgbBlue = ceil((index_range-8)*170/8);
          }
        }
        rgbColors[i].rgbReserved = 0;
        break;
      case 3: //CYAN
        if (index_range<=8) { //1->7 Darker values, 8 is true value
          rgbColors[i].rgbRed = 0;
          rgbColors[i].rgbGreen = ceil(index_range*170/8);
          rgbColors[i].rgbBlue = ceil(index_range*170/8);
        } else { //9->16 Lighter values
          if (index_range==16) {
            rgbColors[i].rgbRed = 160;
          } else {
            rgbColors[i].rgbRed = ceil((index_range-8)*170/8);
          }
          rgbColors[i].rgbGreen = 170;
          rgbColors[i].rgbBlue = 170;
        }
        rgbColors[i].rgbReserved = 0;
        break;
      case 4: //RED
        if (index_range<=8) { //1->7 Darker values, 8 is true value
          rgbColors[i].rgbRed = ceil(index_range*170/8);
          rgbColors[i].rgbGreen = 0;
          rgbColors[i].rgbBlue = 0;
        } else { //9->16 Lighter values
          rgbColors[i].rgbRed = 170;
          if (index_range==16) {
            rgbColors[i].rgbGreen = 160;
            rgbColors[i].rgbBlue = 160;
          } else {
            rgbColors[i].rgbGreen = ceil((index_range-8)*170/8);
            rgbColors[i].rgbBlue = ceil((index_range-8)*170/8);
          }
        }
        rgbColors[i].rgbReserved = 0;
        break;
      case 5: //PURPLE
        if (index_range<=8) { //1->7 Darker values, 8 is true value
          rgbColors[i].rgbRed = ceil((index_range-1)*170/8);
          rgbColors[i].rgbGreen = 0;
          rgbColors[i].rgbBlue = ceil((index_range-1)*170/8);
        } else { //9->16 Lighter values
          rgbColors[i].rgbRed = 170;
          if (index_range==16) {
            rgbColors[i].rgbGreen = 160;
          } else {         
            rgbColors[i].rgbGreen = ceil((index_range-8)*170/8);
          }
          rgbColors[i].rgbBlue = 170;
        }
        rgbColors[i].rgbReserved = 0;
        break;
      case 6: //BROWN
        if (index_range<=8) { //1->7 Darker values, 8 is true value
          rgbColors[i].rgbRed = ceil(index_range*170/8);
          rgbColors[i].rgbGreen = ceil(index_range*85/8);
          rgbColors[i].rgbBlue = 0;
        } else { //9->16 Lighter values
          rgbColors[i].rgbRed = 170;
          rgbColors[i].rgbGreen = 85+ceil((index_range-8)*85/8);
          rgbColors[i].rgbBlue = ceil((index_range-8)*170/8);
        }
        rgbColors[i].rgbReserved = 0;
        break;
      case 7: //DKGRAY
        /*if (index_range==11) {
          rgbColors[i].rgbRed = 86;
          rgbColors[i].rgbGreen = 85;
          rgbColors[i].rgbBlue = 85;
        } else {
          rgbColors[i].rgbRed = 8*index_range+1;    //.. .. .. .. 85 .. .. .. .. 97
          rgbColors[i].rgbGreen = 8*index_range+1;
          rgbColors[i].rgbBlue = 8*index_range+1;
        }*/
        if (index_range<=8) { //1->7 Darker values, 8 is true value
          rgbColors[i].rgbRed = ceil(index_range*86/8);
          rgbColors[i].rgbGreen = ceil(index_range*85/8);
          rgbColors[i].rgbBlue = ceil(index_range*85/8);
        } else { //9->16 Lighter values
          rgbColors[i].rgbRed = 86+ceil((index_range-8)*86/8);
          rgbColors[i].rgbGreen = 85+ceil((index_range-8)*85/8);
          rgbColors[i].rgbBlue = 85+ceil((index_range-8)*85/8);
        }
        rgbColors[i].rgbReserved = 0;
        break;
      case 8: //LTGRAY
        /*if (index_range==6) {
          rgbColors[i].rgbRed = 171;
          rgbColors[i].rgbGreen = 170; // 98 .. .. .. .. 170 .. .. .. .. 242
          rgbColors[i].rgbBlue = 170;
        } else {
          rgbColors[i].rgbRed = 120+8*index_range;
          rgbColors[i].rgbGreen = 120+8*index_range;
          rgbColors[i].rgbBlue = 120+8*index_range;
        }*/

        if (index_range<=8) { //1->7 Darker values, 8 is true value
          rgbColors[i].rgbRed = ceil(index_range*171/8);
          rgbColors[i].rgbGreen = ceil(index_range*170/8);
          rgbColors[i].rgbBlue = ceil(index_range*170/8);
        } else { //9->16 Lighter values
          rgbColors[i].rgbRed = 171+ceil((index_range-8)*10);
          rgbColors[i].rgbGreen = 170+ceil((index_range-8)*10);
          rgbColors[i].rgbBlue = 170+ceil((index_range-8)*10);
        }

        rgbColors[i].rgbReserved = 0;
        break;


//Lighter values
      case 9: //LTBLUE
        if (index_range<=8) { //1->7 Darker values, 8 is true value
          rgbColors[i].rgbRed = 0;
          rgbColors[i].rgbGreen = 0;
          rgbColors[i].rgbBlue = ceil(index_range*255/8);
        } else { //9->16 Lighter values
          rgbColors[i].rgbRed = ceil((index_range-8)*224/8);
          rgbColors[i].rgbGreen = ceil((index_range-8)*224/8);
          rgbColors[i].rgbBlue = 255;
        }
        rgbColors[i].rgbReserved = 0;
        break;
      case 10: //LTGREEN 160->175
        if (index_range<=8) { //1->7 Darker values, 8 is true value
          rgbColors[i].rgbRed = 0;
          rgbColors[i].rgbBlue = 0;
          //if (index_range==7)
            //rgbColors[i].rgbGreen = 254; //<-------- green at 254
          //else
            rgbColors[i].rgbGreen = ceil(index_range*255/8);
        } else { //9->16 Lighter values
          rgbColors[i].rgbRed = ceil((index_range-8)*224/8);
          rgbColors[i].rgbBlue = ceil((index_range-8)*224/8);
          rgbColors[i].rgbGreen = 255;
        }
        rgbColors[i].rgbReserved = 0;
        break;
      case 11: //LTCYAN
        if (index_range<=8) { //1->7 Darker values, 8 is true value
          rgbColors[i].rgbRed = 0;
          rgbColors[i].rgbGreen = ceil(index_range*255/8);
          rgbColors[i].rgbBlue = ceil(index_range*255/8);
        } else { //9->16 Lighter values
          rgbColors[i].rgbRed = ceil((index_range-8)*224/8);
          rgbColors[i].rgbGreen = 255;
          rgbColors[i].rgbBlue = 255;
        }
        rgbColors[i].rgbReserved = 0;
        break;
      case 12: //LTRED
        if (index_range<=8) { //1->7 Darker values, 8 is true value
          rgbColors[i].rgbRed = ceil(index_range*255/8);
          rgbColors[i].rgbGreen = 0;
          rgbColors[i].rgbBlue = 0;
        } else { //9->16 Lighter values
          rgbColors[i].rgbRed = 255;
          rgbColors[i].rgbGreen = ceil((index_range-8)*224/8);
          rgbColors[i].rgbBlue = ceil((index_range-8)*224/8);
        }
        rgbColors[i].rgbReserved = 0;
        break;
      case 13: //LTPURPLE
        if (index_range<=8) { //1->7 Darker values, 8 is true value
          rgbColors[i].rgbRed = ceil(index_range*255/8);
          rgbColors[i].rgbGreen = 0;
          rgbColors[i].rgbBlue = ceil(index_range*255/8);
        } else { //9->16 Lighter values
          rgbColors[i].rgbRed = 255;
          rgbColors[i].rgbGreen = ceil((index_range-8)*224/8);
          rgbColors[i].rgbBlue = 255;
        }
        rgbColors[i].rgbReserved = 0;
        break;
      case 14: //YELLOW
        if (index_range<=8) { //1->7 Darker values, 8 is true value
          rgbColors[i].rgbRed = ceil(index_range*255/8);
          rgbColors[i].rgbGreen = ceil(index_range*255/8);
          rgbColors[i].rgbBlue = 0;
          
        } else { //9->16 Lighter values
          rgbColors[i].rgbRed = 255;
          rgbColors[i].rgbGreen = 255;
          rgbColors[i].rgbBlue = ceil((index_range-8)*224/8);
        }
        rgbColors[i].rgbReserved = 0;
        break;
      case 15: //WHITE
         /* if (index_range<8) {
            rgbColors[i].rgbRed = ceil(index_range*255/8);//ceil((double)(i-16*calc+1)*255/16);
            rgbColors[i].rgbGreen = ceil(index_range*255/8);//ceil((double)(i-16*calc+1)*255/16);
            rgbColors[i].rgbBlue = ceil(index_range*255/8);//ceil((double)(i-16*calc+1)*255/16);
          } else if (index_range>=9){
            rgbColors[i].rgbRed = 255-ceil(index_range*255/8);//ceil((double)(i-16*calc+1)*255/16);
            rgbColors[i].rgbGreen = 255-ceil(index_range*255/8);//ceil((double)(i-16*calc+1)*255/16);
            rgbColors[i].rgbBlue = 255-ceil(index_range*255/8);//ceil((double)(i-16*calc+1)*255/16);
          }
        }*/
        rgbColors[i].rgbRed =  255;//ceil((double)(i-16*calc+1)*255/16);
        rgbColors[i].rgbGreen = 255;//ceil((double)(i-16*calc+1)*255/16);
        rgbColors[i].rgbBlue = 255;//ceil((double)(i-16*calc+1)*255/16);
        rgbColors[i].rgbReserved = 0;
        break;
      /*default:
        rgbColors[i].rgbRed = 255;
        rgbColors[i].rgbGreen = 255;
        rgbColors[i].rgbBlue = 255;
        rgbColors[i].rgbReserved = 0;
        break;*/
    }
  }
}

int rgbPaint[256];
void Init8BitRGBPaintDefault(int *rgbPaint_dest,RGBQUAD *rgbColors_src,bool is_ascending,int start_paint_index)
{
  int index=0;
  //int start_paint_index=8;
  int paint_index=0;


  paint_index=start_paint_index;
  if (is_ascending) {
    start_paint_index++;
  } else {
    start_paint_index--;
  }
  for (int x=0;x<16;x++) { //left to right
    for (int y=0;y<16;y++) { //up to down 
      rgbPaint_dest[index]=RGB(rgbColors_src[paint_index].rgbRed,rgbColors_src[paint_index].rgbGreen,rgbColors_src[paint_index].rgbBlue);
      index++;
      paint_index+=16;
    }
    paint_index=start_paint_index;
    if (is_ascending) {//shift darker/lighter
      start_paint_index++; 
    } else {
      start_paint_index--; 
    }
    if(start_paint_index>15) {
      start_paint_index=0;
    }
    if (start_paint_index<0) {
      start_paint_index=15;
    }
  }
}


void BitmapPalette(HDC hdc, HDC hdc2,HBITMAP hBitmap,RGBQUAD *bitmapPalette) {
  /*HDC hdc2 = CreateCompatibleDC(hdc);
  HBITMAP hOldBitmap;
  
  hOldBitmap = SelectObject(hdc2, hBitmap);
  SetDIBColorTable(hdc2, 0, 256, bitmapPalette);
  SelectObject(hdc2, hOldBitmap);
  DeleteObject(hOldBitmap);
  DeleteDC(hdc2);*/

  SelectObject(hdc2, hBitmap);
  SetDIBColorTable(hdc2, 0, 256, bitmapPalette);
}




HBITMAP CreateLargeBitmap(int cx, int cy)
{
//https://forums.codeguru.com/showthread.php?526563-Accessing-Pixels-with-CreateDIBSection
 unsigned char* lpBitmapBits; 

  BITMAPINFO bi; 
  ZeroMemory(&bi, sizeof(BITMAPINFO));
  bi.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);
  bi.bmiHeader.biWidth=cx;
  bi.bmiHeader.biHeight=-cy;
  bi.bmiHeader.biPlanes=1;
  bi.bmiHeader.biBitCount=32;
  return CreateDIBSection(NULL, &bi,DIB_RGB_COLORS, (VOID**)&lpBitmapBits,NULL,0);
}



HBITMAP Create1BitBitmap(int cx, int cy)
{
  BITMAPINFO* pbmi = (BITMAPINFO*)alloca(offsetof(BITMAPINFO, bmiColors[2]));
  pbmi->bmiHeader.biSize = sizeof (pbmi->bmiHeader);
  pbmi->bmiHeader.biWidth = cx;
  pbmi->bmiHeader.biHeight = cy;
  pbmi->bmiHeader.biPlanes = 1;
  pbmi->bmiHeader.biBitCount = 1;
  pbmi->bmiHeader.biCompression = BI_RGB;
  pbmi->bmiHeader.biSizeImage = 0;

  pbmi->bmiColors[0].rgbRed = 0;
  pbmi->bmiColors[0].rgbGreen = 0;
  pbmi->bmiColors[0].rgbBlue = 0;
  pbmi->bmiColors[0].rgbReserved = 0;

  pbmi->bmiColors[1].rgbRed = 255;
  pbmi->bmiColors[1].rgbGreen = 255;
  pbmi->bmiColors[1].rgbBlue = 255;
  pbmi->bmiColors[1].rgbReserved = 0;

  pbmi->bmiHeader.biClrUsed = 0;
  pbmi->bmiHeader.biClrImportant = 0;
  PVOID pv;
  return CreateDIBSection(NULL,pbmi,DIB_RGB_COLORS,&pv,NULL,0);
}



HBITMAP CreateCrunchyBitmap(int cx, int cy)
{
  BITMAPINFO* pbmi = (BITMAPINFO*)alloca(offsetof(BITMAPINFO, bmiColors[256]));
  pbmi->bmiHeader.biSize = sizeof (pbmi->bmiHeader);
  pbmi->bmiHeader.biWidth = cx;
  pbmi->bmiHeader.biHeight = cy;
  pbmi->bmiHeader.biPlanes = 1;
  pbmi->bmiHeader.biBitCount = 8;
  pbmi->bmiHeader.biCompression = BI_RGB;
  pbmi->bmiHeader.biSizeImage = 0;

  pbmi->bmiHeader.biXPelsPerMeter = 14173;
  pbmi->bmiHeader.biYPelsPerMeter = 14173;
  pbmi->bmiHeader.biClrUsed = 0;
  pbmi->bmiHeader.biClrImportant = 0;

  Init8BitRGBColorsDefault(pbmi->bmiColors);

  pbmi->bmiHeader.biClrUsed = 0;
  pbmi->bmiHeader.biClrImportant = 0;
  PVOID pv;
  return CreateDIBSection(NULL,pbmi,DIB_RGB_COLORS,&pv,NULL,0);
}



#define COLORREF2RGB(Color) (Color & 0xff00) | ((Color >> 16) & 0xff) \
                                 | ((Color << 16) & 0xff0000)
//-------------------------------------------------------------------------------
// ReplaceColor
//
// Author    : Dimitri Rochette drochette@coldcat.fr
// Specials Thanks to Joe Woodbury for his comments and code corrections
//
// Includes  : Only <windows.h>

//
// hBmp         : Source Bitmap
// cOldColor : Color to replace in hBmp
// cNewColor : Color used for replacement
// hBmpDC    : DC of hBmp ( default NULL ) could be NULL if hBmp is not selected
//
// Retcode   : HBITMAP of the modified bitmap or NULL for errors
//
//-------------------------------------------------------------------------------
HBITMAP ReplaceColor(HBITMAP hBmp,COLORREF cOldColor,COLORREF cNewColor,HDC hBmpDC)
{//https://www.codeproject.com/Articles/2841/How-to-replace-a-color-in-a-HBITMAP
    HBITMAP RetBmp=NULL;
    if (hBmp)
    {
        HDC BufferDC=CreateCompatibleDC(NULL);    // DC for Source Bitmap
        if (BufferDC)
        {
            HBITMAP hTmpBitmap = (HBITMAP) NULL;
            if (hBmpDC)
                if (hBmp == (HBITMAP)GetCurrentObject(hBmpDC, OBJ_BITMAP))
            {
                hTmpBitmap = CreateLargeBitmap(1,1);//CreateBitmap(1, 1, 1, 1, NULL);
                SelectObject(hBmpDC, hTmpBitmap);
            }

            HGDIOBJ PreviousBufferObject=SelectObject(BufferDC,hBmp);
            // here BufferDC contains the bitmap
            
            HDC DirectDC=CreateCompatibleDC(NULL); // DC for working
            if (DirectDC)
            {
                // Get bitmap size
                BITMAP bm;
                GetObject(hBmp, sizeof(bm), &bm);

                // create a BITMAPINFO with minimal initilisation 
                // for the CreateDIBSection
                BITMAPINFO RGB32BitsBITMAPINFO; 
                ZeroMemory(&RGB32BitsBITMAPINFO,sizeof(BITMAPINFO));
                RGB32BitsBITMAPINFO.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);
                RGB32BitsBITMAPINFO.bmiHeader.biWidth=bm.bmWidth;
                RGB32BitsBITMAPINFO.bmiHeader.biHeight=bm.bmHeight;
                RGB32BitsBITMAPINFO.bmiHeader.biPlanes=1;
                RGB32BitsBITMAPINFO.bmiHeader.biBitCount=32;

                // pointer used for direct Bitmap pixels access
                UINT * ptPixels;    

                HBITMAP DirectBitmap = CreateDIBSection(DirectDC, 
                                       (BITMAPINFO *)&RGB32BitsBITMAPINFO, 
                                       DIB_RGB_COLORS,
                                       (void **)&ptPixels, 
                                       NULL, 0);
                if (DirectBitmap)
                {
                    // here DirectBitmap!=NULL so ptPixels!=NULL no need to test
                    HGDIOBJ PreviousObject=SelectObject(DirectDC, DirectBitmap);
                    BitBlt(DirectDC,0,0,
                                   bm.bmWidth,bm.bmHeight,
                                   BufferDC,0,0,SRCCOPY);

                       // here the DirectDC contains the bitmap

                    // Convert COLORREF to RGB (Invert RED and BLUE)
                    //cOldColor=COLORREF2RGB(cOldColor);
                    //cNewColor=COLORREF2RGB(cNewColor);

                    // After all the inits we can do the job : Replace Color
                    for (int i=((bm.bmWidth*bm.bmHeight)-1);i>=0;i--)
                    {
                        if (ptPixels[i]==BLACK) 
                          ptPixels[i]=DKBLACK;                    
                        else if (ptPixels[i]==cOldColor) 
                          ptPixels[i]=cNewColor;
                    }
                    // little clean up
                    // Don't delete the result of SelectObject because it's 
                    // our modified bitmap (DirectBitmap)
                       SelectObject(DirectDC,PreviousObject);

                    // finish
                    RetBmp=DirectBitmap;
                }
                // clean up
                DeleteDC(DirectDC);
            }            
            if (hTmpBitmap)
            {
                SelectObject(hBmpDC, hBmp);
                DeleteObject(hTmpBitmap);
            }
            SelectObject(BufferDC,PreviousBufferObject);
            // BufferDC is now useless
            DeleteDC(BufferDC);
        }
    }
    return RetBmp;
}




HBITMAP CreateBitmapMask(HBITMAP hbmColour, COLORREF crTransparent, HDC hdc)
{//http://www.winprog.org/tutorial/transparency.html
    HDC hdcMem, hdcMem2;
    HBITMAP hbmMask;
    BITMAP bm;

    // Create monochrome (1 bit) mask bitmap.  

    GetObject(hbmColour, sizeof(BITMAP), &bm);
    hbmMask = CreateBitmap(bm.bmWidth, bm.bmHeight, 1, 1, NULL);

    // Get some HDCs that are compatible with the display driver

    hdcMem = CreateCompatibleDC(hdc);
    hdcMem2 = CreateCompatibleDC(hdc);

    SelectObject(hdcMem, hbmColour);
    SelectObject(hdcMem2, hbmMask);

    // Set the background colour of the colour image to the colour
    // you want to be transparent.
    SetBkColor(hdcMem, crTransparent);

    // Copy the bits from the colour image to the B+W mask... everything
    // with the background colour ends up white while everythig else ends up
    // black...Just what we wanted.

    BitBlt(hdcMem2, 0, 0, bm.bmWidth, bm.bmHeight, hdcMem, 0, 0, SRCCOPY);

    // Take our new mask and use it to turn the transparent colour in our
    // original colour image to black so the transparency effect will
    // work right.
    BitBlt(hdcMem, 0, 0, bm.bmWidth, bm.bmHeight, hdcMem2, 0, 0, SRCINVERT);

    // Clean up.

    DeleteDC(hdcMem);
    DeleteDC(hdcMem2);

    return hbmMask;
}


//Graphics
void GrRect(HDC hdc, double x,double y,int l, int h,int COLOR) {
  HBRUSH hBrush,holdBrush;
  HPEN hPen,holdPen;

  hBrush = CreateSolidBrush(COLOR);
  hPen=CreatePen(PS_NULL,1,COLOR);
  holdPen=SelectObject(hdc,hPen);
  holdBrush=(HBRUSH) SelectObject(hdc,hBrush);

  Rectangle(hdc,x,y,x+l,y+h);

  SelectObject(hdc, holdBrush);
  SelectObject(hdc, holdPen);
  DeleteObject(hPen);
  DeleteObject(hBrush);
}


//https://stackoverflow.com/questions/10966008/draw-slightly-transparent-blue-rectangle-in-native-win32-gdi
//https://www.codeproject.com/Articles/286/Using-the-AlphaBlend-function
void GrGlassRect(HDC hdc, HDC hdcMem, int x, int y, int width, int height, int COLOR, BYTE alpha) {
    BLENDFUNCTION blendFunction;
    blendFunction.BlendOp = AC_SRC_OVER;
    blendFunction.BlendFlags = 0;
    blendFunction.SourceConstantAlpha = alpha; // Transparency level (0-255)
    blendFunction.AlphaFormat = 0;

    HBITMAP hBitmap = CreateCompatibleBitmap(hdc, width, height);
    SelectObject(hdcMem, hBitmap);

    // Fill the rectangle with the desired color
    HBRUSH hBrush = CreateSolidBrush(COLOR); // Blue color
    RECT rect = {0, 0, width, height};
    FillRect(hdcMem, &rect, hBrush);

    // Use AlphaBlend to draw the transparent rectangle
    AlphaBlend(hdc, x, y, width, height, hdcMem, 0, 0, width, height, blendFunction);

    // Clean up
    DeleteObject(hBrush);
    DeleteObject(hBitmap);
}






void GrLine(HDC hdc, double x1,double y1,double x2,double y2,int COLOR) {
  HPEN hPen = CreatePen(PS_SOLID, 1, COLOR);
  HPEN hOldPen = SelectObject(hdc, hPen);
  MoveToEx(hdc,x1,y1,NULL);
  LineTo(hdc,x2,y2);
  SelectObject(hdc, hOldPen);
  DeleteObject(hPen);
}


void GrCircle(HDC hdc, double x, double y, int size, int COLOR, int COLOR_2) {
//Shape Coordinates
  double x1=x-size;
  double y1=y-size;
  double x2=x+size;
  double y2=y+size;

  int left = min(x1, x2);
  int top = min(y1, y2);
  int right = max(x1, x2);
  int bottom = max(y1, y2);

  int length = min(abs(x2-x1), abs(y2-y1));
  if (x2 < x1)
    left = right - length;
  else
    right = left + length;

  if (y2 < y1)
    top = bottom - length;
  else
    bottom = top + length;

  //Draw circle
  SelectObject(hdc, GetStockObject(DC_PEN));
  if (COLOR_2==-1) {
    SelectObject(hdc, GetStockObject(HOLLOW_BRUSH)); //Draw circle with no fill
    SetDCPenColor(hdc, COLOR); //BORDER
  } else {
    SelectObject(hdc, GetStockObject(DC_BRUSH));
    SetDCBrushColor(hdc, COLOR); //SOLID FILL
    SetDCPenColor(hdc, COLOR_2); //BORDER
  }

  Ellipse(hdc, left, top, right, bottom);
}


void GrPrintW(HDC hdc, double x1, double y1, wchar_t *_txt, char *_atxt, int color, int _height, bool A,bool is_unifont) 
{
  LPCWSTR txt=_txt;
  LPCSTR atxt=_atxt;
  HFONT hf;

  if (is_unifont) {
    hf=CreateFontW(_height, //Height
                0, //cWidth
                0, //cescapement
                0, //corientation
                FW_MEDIUM, //cweight
                FALSE, //bitalic
                FALSE, //bunderline
                0, //bstrikeout
                0, //icharset
                0, //ioutprecision
                0,//iclip precision
                0, //iqyaluty
                0, //ipitchandfamily
                L"Unifont");  //pszfacename
  } else {
    hf=CreateFontW(_height, //Height
                0, //cWidth
                0, //cescapement
                0, //corientation
                FW_MEDIUM, //cweight
                FALSE, //bitalic
                FALSE, //bunderline
                0, //bstrikeout
                0, //icharset
                0, //ioutprecision
                0,//iclip precision
                0, //iqyaluty
                0, //ipitchandfamily
                L"Arial");  //pszfacename
  }

  HFONT hfOld = SelectObject(hdc,hf);
  SelectObject(hdc,hf);

  SetTextColor(hdc, color); //set color of the text to be drawn
  SetBkMode(hdc, TRANSPARENT); //makes background of txt transparent  //https://stackoverflow.com/questions/10571966/  
  RECT rect;
  //GetClientRect(hwnd, &rect);
  rect.left=x1;
  rect.top=y1;
  
  //TextOutA(hdc, x1, y1, txt_reverse, txt_len); //draw text to screen
  if (!A) {
    //TextOut(hdc, x1, y1, txt, wcslen(txt)); //draw text to screen
    DrawText(hdc, txt, -1, &rect, DT_NOCLIP);
  } else {
    //TextOutA(hdc, x1, y1, atxt, strlen(atxt)); //draw text to screen
    DrawTextA(hdc, atxt, -1, &rect, DT_NOCLIP);
  }
  SelectObject(hdc,hfOld);
  DeleteObject(hfOld);
  DeleteObject(hf);
  SetTextColor(hdc, TRANSPARENT);
}


void GrPrint(HDC hdc, double x1, double y1, char *_txt, int color) 
{//https://forums.codeguru.com/showthread.php?329037-Drawtext-with-japanese-character
  //DWORD color;
  //HFONT hFont, holdFont;
  //color=GetSysColor(COLOR_BTNFACE);
  //SetBkColor(hdc,color);
  //holdFont=SelectObject(hdc,hFont);

  LPCSTR txt = _txt; //convert text to lpcstr
  SetTextColor(hdc, color); //set color of the text to be drawn
  SetBkMode(hdc, TRANSPARENT); //makes background of txt transparent  //https://stackoverflow.com/questions/10571966/draw-print-text-with-transparent-background-in-c-win32
  TextOutA(hdc, x1, y1, txt, strlen(txt)); //draw text to screen
  SetTextColor(hdc, TRANSPARENT);
}





void GrPrintA(HDC hdc, double x1, double y1, wchar_t *_txt, int color) 
{//https://forums.codeguru.com/showthread.php?329037-Drawtext-with-japanese-character
//https://stackoverflow.com/questions/1974015/how-to-use-drawtext-to-write-text-in-a-given-window-whose-handle-is-known

  LPCWSTR txt = _txt; //convert text to lpcstr
  SetTextColor(hdc, color); //set color of the text to be drawn
  SetBkMode(hdc, TRANSPARENT); //makes background of txt transparent
  RECT rect;
  //GetClientRect(hwnd, &rect);
  rect.left=x1;
  rect.top=y1;
  DrawText(hdc, txt, -1, &rect, DT_NOCLIP);

  SetTextColor(hdc, TRANSPARENT);
}



//void DrawBitmap(HDC hDC,double _x1,double _y1, double _x2, double _y2, int width, int height, HBITMAP hSourceBitmap,int _SRCTYPE,bool stretch,bool is_left)
void DrawBitmap(HDC hDC, HDC hdcMem,double _x1,double _y1, double _x2, double _y2, int width, int height, HBITMAP hSourceBitmap,int _SRCTYPE,bool stretch,bool is_left)

{
  if (hSourceBitmap!=NULL) {
    BITMAP bitmap;
    //HDC hdcMem = CreateCompatibleDC(hDC);
    GetObject(hSourceBitmap,sizeof(bitmap),&bitmap);
    SelectObject(hdcMem,hSourceBitmap);
    int b_width=width;
    if (is_left) {
      b_width=-bitmap.bmWidth-1;
      _x1+=width;
    }
    if (stretch || is_left)
      StretchBlt(hDC, _x1, _y1, b_width, height, hdcMem, 0,0, bitmap.bmWidth, bitmap.bmHeight, _SRCTYPE); //draw to 
     //StretchBlt(hDC, _x1+bitmap.bmWidth/2, _y1-bitmap.bmHeight/2, -bitmap.bmWidth-1, bitmap.bmHeight, hdcMemA, 0,0, bitmap.bmWidth, bitmap.bmHeight, SRCAND); //Create Mask for
    else
      BitBlt(hDC, _x1, _y1, width, height, hdcMem, _x2, _y2, _SRCTYPE);
    //DeleteDC(hdcMem);
  }
}



/*void DrawGlassBitmap(HDC hDC,double _x1,double _y1, double _x2, double _y2, int width, int height, HBITMAP hSourceBitmap,bool stretch,bool is_left)
{
  if (hSourceBitmap!=NULL) {
    BITMAP bitmap;
    HDC hdcMem = CreateCompatibleDC(hDC);
    GetObject(hSourceBitmap,sizeof(bitmap),&bitmap);
    SelectObject(hdcMem,hSourceBitmap);
    int b_width=width;
    if (is_left) {
      b_width=-bitmap.bmWidth-1;
      _x1+=width;
    }
    if (stretch || is_left)
      TransparentBlt(hDC, _x1, _y1, b_width, height, hdcMem, 0,0, bitmap.bmWidth, bitmap.bmHeight, BLACK);
    else
      TransparentBlt(hDC, _x1, _y1, width, height, hdcMem, 0,0, bitmap.bmWidth, bitmap.bmHeight, BLACK);
    DeleteDC(hdcMem);
  }
}*/



//Set values to variables
void SetRotatedSpriteSize(HDC hDC, HBITMAP hSourceBitmap,double radians, int *minx, int *miny, int *maxx, int *maxy, int *width, int *height, double *_cosine, double *_sine)
{
  HBITMAP hOldSourceBitmap; ////https://www.codeguru.com/multimedia/rotate-a-bitmap-image/
  HDC hMemSrc;
  BITMAP iSrcBitmap;

  hMemSrc = CreateCompatibleDC(hDC);
  GetObject(hSourceBitmap, sizeof(BITMAP), (LPSTR)&iSrcBitmap);

  // Get logical coordinates
  double cosine = (double)cos(radians);
  double sine = (double)sin(radians);

  // Compute dimensions of the resulting bitmap
  // First get the coordinates of the 3 corners other than origin
  int x1 = (int)(-iSrcBitmap.bmHeight * sine);
  int y1 = (int)(iSrcBitmap.bmHeight * cosine);
  int x2 = (int)(iSrcBitmap.bmWidth * cosine - iSrcBitmap.bmHeight * sine);
  int y2 = (int)(iSrcBitmap.bmHeight * cosine + iSrcBitmap.bmWidth * sine);
  int x3 = (int)(iSrcBitmap.bmWidth * cosine);
  int y3 = (int)(iSrcBitmap.bmWidth * sine);

  int _minx = min(0,min(x1, min(x2,x3)));
  int _miny = min(0,min(y1, min(y2,y3)));
  int _maxx = max(0,max(x1, max(x2,x3)));
  int _maxy = max(0, max(y1, max(y2,y3)));

  *minx=_minx;
  *miny=_miny;
  *maxx=_maxx;
  *maxy=_maxy;

  *width = (_maxx - _minx);
  *height = (_maxy - _miny);

  *_cosine = cosine;
  *_sine = sine;

  hOldSourceBitmap = SelectObject(hMemSrc, hSourceBitmap);
  SelectObject(hMemSrc, hOldSourceBitmap);
  DeleteObject(hOldSourceBitmap);
  DeleteDC(hMemSrc);
}



//After finding the rotated sprite size, begin drawing
void RotateSpriteII(HDC hDC, HBITMAP hSourceBitmap, HBITMAP hDestBitmap, double cosine,double sine, int rTransparent, int sprite_color, int sprite_color_2, int minx, int miny, int maxx, int maxy, int y)
{ //if (hSourceBitmap != NULL) { ////https://ftp.zx.net.nz/pub/Patches/ftp.microsoft.com/MISC/KB/en-us/77/127.HTM
  HBITMAP hOldSourceBitmap, hOldDestBitmap; ////https://www.codeguru.com/multimedia/rotate-a-bitmap-image/
  HDC hMemSrc,hMemDest;
  BITMAP iSrcBitmap;

  hMemSrc = CreateCompatibleDC(hDC);
  hMemDest= CreateCompatibleDC(hDC);

  GetObject(hSourceBitmap, sizeof(BITMAP), (LPSTR)&iSrcBitmap);
  hOldSourceBitmap = SelectObject(hMemSrc, hSourceBitmap);
  hOldDestBitmap = SelectObject(hMemDest, hDestBitmap);

  // Set mapping mode so that +ve y axis is upwords
  SetMapMode(hMemSrc, MM_ISOTROPIC);
  SetWindowExtEx(hMemSrc, 1,1,NULL);
  SetViewportExtEx(hMemSrc, 1,-1,NULL);
  SetViewportOrgEx(hMemSrc, 0, iSrcBitmap.bmHeight-1,NULL);

  SetMapMode(hMemDest, MM_ISOTROPIC);
  SetWindowExtEx(hMemDest, 1,1,NULL);
  SetViewportExtEx(hMemDest, 1,-1,NULL);
  SetWindowOrgEx(hMemDest, minx, maxy-1,NULL);

   // Step 4: Copy the pixels from the source to the destination.
  int current_pixel=0;
  //for (int y=miny;y<maxy;y++) { //0 to max height of bitmap
  for(int x=minx;x<maxx;x++) { //0 to max width of bitmap
	int sourcex = (int)(x*cosine+y*sine); //get pixel from sprite, x-axis
	int sourcey = (int)(y*cosine-x*sine); //get pixel from sprite, y-axis
	if(sourcex>=0 && sourcex<iSrcBitmap.bmWidth && sourcey>=0
	 	 && sourcey<iSrcBitmap.bmHeight ) {
      current_pixel=GetPixel(hMemSrc,sourcex,sourcey); //get current pixel color



      if (current_pixel==rTransparent) { //Set Target Transparent color (i.e. LTGREEN) to BLACK
	    SetPixel(hMemDest, x, y, BLACK);
      } else if (current_pixel==BLACK){
        if (sprite_color_2==-1) { //custom flag to disallow dithreing
          if (sprite_color!=BLACK) { //Set BLACK to Custom Color
	        SetPixel(hMemDest, x, y, sprite_color);
          } else { //change BLACK to DKBLACK 
	        SetPixel(hMemDest, x, y, DKBLACK);
          }
        } else { //dither color of sprite
          if (sprite_color!=BLACK) { //Set BLACK to Custom Color
            if (y%2==0) {
              if (x%2==0) {
	            SetPixel(hMemDest, x, y, sprite_color_2);
              } else {
	            SetPixel(hMemDest, x, y, sprite_color);
              }
            } else {
              if (x%2!=0) {
	            SetPixel(hMemDest, x, y, sprite_color_2);
              } else {
	            SetPixel(hMemDest, x, y, sprite_color);
              }
            }
          } else { //change BLACK to DKBLACK 
	        SetPixel(hMemDest, x, y, DKBLACK);
          }
        }
      } else { //Set pixel, no change to color
	    SetPixel(hMemDest, x, y, current_pixel);
      }



    }
  }
  //}

 // Step 5: Destroy the DCs.
  //DeleteObject(SelectObject(hMemSrc, hOldSourceBitmap));
  //DeleteObject(SelectObject(hMemDest, hOldDestBitmap));
  SelectObject(hMemSrc, hOldSourceBitmap);
  SelectObject(hMemDest, hOldDestBitmap);
  DeleteObject(hOldSourceBitmap);
  DeleteObject(hOldDestBitmap);
  DeleteDC(hMemDest);
  DeleteDC(hMemSrc);
}


HBITMAP RotateSpriteExclude(HDC hDC, HBITMAP hSourceBitmap, double radians, int old_color, int sprite_color) 
{ //if (hSourceBitmap != NULL) { ////https://ftp.zx.net.nz/pub/Patches/ftp.microsoft.com/MISC/KB/en-us/77/127.HTM
  HBITMAP hOldSourceBitmap, hOldDestBitmap, hDestBitmap; ////https://www.codeguru.com/multimedia/rotate-a-bitmap-image/
  HDC hMemSrc,hMemDest;
  BITMAP iSrcBitmap;

  // Step 1: Create a memory DC for the source and destination bitmaps
  //         compatible with the device used.
  hMemSrc = CreateCompatibleDC(hDC);
  hMemDest= CreateCompatibleDC(hDC);


  // Step 2: Get the height and width of the source bitmap.
  GetObject(hSourceBitmap, sizeof(BITMAP), (LPSTR)&iSrcBitmap);

  // Get logical coordinates
  double cosine = (double)cos(radians);
  double sine = (double)sin(radians);

  // Compute dimensions of the resulting bitmap
  // First get the coordinates of the 3 corners other than origin
  int x1 = (int)(-iSrcBitmap.bmHeight * sine);
  int y1 = (int)(iSrcBitmap.bmHeight * cosine);
  int x2 = (int)(iSrcBitmap.bmWidth * cosine - iSrcBitmap.bmHeight * sine);
  int y2 = (int)(iSrcBitmap.bmHeight * cosine + iSrcBitmap.bmWidth * sine);
  int x3 = (int)(iSrcBitmap.bmWidth * cosine);
  int y3 = (int)(iSrcBitmap.bmWidth * sine);

  int minx = min(0,min(x1, min(x2,x3)));
  int miny = min(0,min(y1, min(y2,y3)));
  int maxx = max(0,max(x1, max(x2,x3)));
  int maxy = max(0, max(y1, max(y2,y3)));

  int width = maxx - minx;
  int height = maxy - miny;

   // Step 3: Select the source bitmap into the source DC. Create a
   //         destination bitmap, and select it into the destination DC.

   //hDestBitmap = NULL;//CreateCompatibleBitmap(hMemDest, width, height);
  /*hDestBitmap = CreateBitmap(height, width, iSrcBitmap.bmPlanes,
                  iSrcBitmap.bmBitsPixel, NULL);*/

  hDestBitmap = CreateCrunchyBitmap(width,height);//CreateLargeBitmap(height, width);
  hOldSourceBitmap = SelectObject(hMemSrc, hSourceBitmap);
  hOldDestBitmap = SelectObject(hMemDest, hDestBitmap);

  // Set mapping mode so that +ve y axis is upwords
  SetMapMode(hMemSrc, MM_ISOTROPIC);
  SetWindowExtEx(hMemSrc, 1,1,NULL);
  SetViewportExtEx(hMemSrc, 1,-1,NULL);
  SetViewportOrgEx(hMemSrc, 0, iSrcBitmap.bmHeight-1,NULL);

  SetMapMode(hMemDest, MM_ISOTROPIC);
  SetWindowExtEx(hMemDest, 1,1,NULL);
  SetViewportExtEx(hMemDest, 1,-1,NULL);
  SetWindowOrgEx(hMemDest, minx, maxy-1,NULL);

   // Step 4: Copy the pixels from the source to the destination.
  int current_pixel=0;
  for (int y=miny;y<maxy;y++) { //0 to max height of bitmap
	for(int x=minx;x<maxx;x++) { //0 to max width of bitmap
	  int sourcex = (int)(x*cosine+y*sine); //get pixel from sprite, x-axis
	  int sourcey = (int)(y*cosine-x*sine); //get pixel from sprite, y-axis
	  if(sourcex>=0 && sourcex<iSrcBitmap.bmWidth && sourcey>=0
	   	 && sourcey<iSrcBitmap.bmHeight ) {
         current_pixel=GetPixel(hMemSrc,sourcex,sourcey); //get current pixel color
        if (current_pixel==old_color){
          if (sprite_color!=BLACK) { //Set BLACK to Custom Color
            SetPixel(hMemDest, x, y, sprite_color);
          } else { //change BLACK to DKBLACK 
            SetPixel(hMemDest, x, y, DKBLACK);
          }
        } else {
          SetPixel(hMemDest, x, y, BLACK);
        }
      }
    }
  }

 // Step 5: Destroy the DCs.
  //DeleteObject(SelectObject(hMemSrc, hOldSourceBitmap));
  //DeleteObject(SelectObject(hMemDest, hOldDestBitmap));
  SelectObject(hMemSrc, hOldSourceBitmap);
  SelectObject(hMemDest, hOldDestBitmap);
  DeleteObject(hOldSourceBitmap);
  DeleteObject(hOldDestBitmap);
  DeleteDC(hMemDest);
  DeleteDC(hMemSrc);
  return (hDestBitmap);
}

HBITMAP RotateSpriteSimple(HDC hDC, HBITMAP hSourceBitmap, double radians, int background_color)
{ //if (hSourceBitmap != NULL) { ////https://ftp.zx.net.nz/pub/Patches/ftp.microsoft.com/MISC/KB/en-us/77/127.HTM
  HBITMAP hOldSourceBitmap, hOldDestBitmap, hDestBitmap; ////https://www.codeguru.com/multimedia/rotate-a-bitmap-image/
  HDC hMemSrc,hMemDest;
  BITMAP iSrcBitmap;

  // Step 1: Create a memory DC for the source and destination bitmaps
  //         compatible with the device used.
  hMemSrc = CreateCompatibleDC(hDC);
  hMemDest= CreateCompatibleDC(hDC);


  // Step 2: Get the height and width of the source bitmap.
  GetObject(hSourceBitmap, sizeof(BITMAP), (LPSTR)&iSrcBitmap);

  // Get logical coordinates
  double cosine = (double)cos(radians);
  double sine = (double)sin(radians);

  // Compute dimensions of the resulting bitmap
  // First get the coordinates of the 3 corners other than origin
  int x1 = (int)(-iSrcBitmap.bmHeight * sine);
  int y1 = (int)(iSrcBitmap.bmHeight * cosine);
  int x2 = (int)(iSrcBitmap.bmWidth * cosine - iSrcBitmap.bmHeight * sine);
  int y2 = (int)(iSrcBitmap.bmHeight * cosine + iSrcBitmap.bmWidth * sine);
  int x3 = (int)(iSrcBitmap.bmWidth * cosine);
  int y3 = (int)(iSrcBitmap.bmWidth * sine);

  int minx = min(0,min(x1, min(x2,x3)));
  int miny = min(0,min(y1, min(y2,y3)));
  int maxx = max(0,max(x1, max(x2,x3)));
  int maxy = max(0, max(y1, max(y2,y3)));

  int width = maxx - minx;
  int height = maxy - miny;


  hDestBitmap = CreateCrunchyBitmap(width,height);//CreateLargeBitmap(height, width);
  hOldSourceBitmap = SelectObject(hMemSrc, hSourceBitmap);
  hOldDestBitmap = SelectObject(hMemDest, hDestBitmap);

  // Set mapping mode so that +ve y axis is upwords
  SetMapMode(hMemSrc, MM_ISOTROPIC);
  SetWindowExtEx(hMemSrc, 1,1,NULL);
  SetViewportExtEx(hMemSrc, 1,-1,NULL);
  SetViewportOrgEx(hMemSrc, 0, iSrcBitmap.bmHeight-1,NULL);

  SetMapMode(hMemDest, MM_ISOTROPIC);
  SetWindowExtEx(hMemDest, 1,1,NULL);
  SetViewportExtEx(hMemDest, 1,-1,NULL);
  SetWindowOrgEx(hMemDest, minx, maxy-1,NULL);

   // Step 4: Copy the pixels from the source to the destination.
  int current_pixel=0;
  for (int y=miny;y<maxy;y++) { //0 to max height of bitmap
	for(int x=minx;x<maxx;x++) { //0 to max width of bitmap
	  int sourcex = (int)(x*cosine+y*sine); //get pixel from sprite, x-axis
	  int sourcey = (int)(y*cosine-x*sine); //get pixel from sprite, y-axis
	  if(sourcex>=0 && sourcex<iSrcBitmap.bmWidth && sourcey>=0
	   	 && sourcey<iSrcBitmap.bmHeight ) {
         current_pixel=GetPixel(hMemSrc,sourcex,sourcey); //get current pixel color
         SetPixel(hMemDest, x, y, current_pixel);
      } else {
        SetPixel(hMemDest, x, y, background_color);
      }
    }
  }

 // Step 5: Destroy the DCs.
  //DeleteObject(SelectObject(hMemSrc, hOldSourceBitmap));
  //DeleteObject(SelectObject(hMemDest, hOldDestBitmap));
  SelectObject(hMemSrc, hOldSourceBitmap);
  SelectObject(hMemDest, hOldDestBitmap);
  DeleteObject(hOldSourceBitmap);
  DeleteObject(hOldDestBitmap);
  DeleteDC(hMemDest);
  DeleteDC(hMemSrc);
  return (hDestBitmap);
}


/*HBITMAP ColorReplaceSprite(HDC hDC, HBITMAP hSourceBitmap, int sprite_color,int background_color) 
{ //if (hSourceBitmap != NULL) { ////https://ftp.zx.net.nz/pub/Patches/ftp.microsoft.com/MISC/KB/en-us/77/127.HTM
  HBITMAP hOldSourceBitmap, hOldDestBitmap, hDestBitmap; ////https://www.codeguru.com/multimedia/rotate-a-bitmap-image/
  HDC hMemSrc,hMemDest;
  BITMAP iSrcBitmap;

  hMemSrc = CreateCompatibleDC(hDC);
  hMemDest= CreateCompatibleDC(hDC);

  GetObject(hSourceBitmap, sizeof(BITMAP), (LPSTR)&iSrcBitmap);

  int width = iSrcBitmap.bmWidth;
  int height = iSrcBitmap.bmHeight;

  hDestBitmap = CreateCrunchyBitmap(width,height);//CreateLargeBitmap(height, width);
  hOldSourceBitmap = SelectObject(hMemSrc, hSourceBitmap);
  hOldDestBitmap = SelectObject(hMemDest, hDestBitmap);

  // Set mapping mode so that +ve y axis is upwords
  SetMapMode(hMemSrc, MM_ISOTROPIC);
  SetWindowExtEx(hMemSrc, 1,1,NULL);
  SetViewportExtEx(hMemSrc, 1,-1,NULL);
  SetViewportOrgEx(hMemSrc, 0, iSrcBitmap.bmHeight-1,NULL);

  SetMapMode(hMemDest, MM_ISOTROPIC);
  SetWindowExtEx(hMemDest, 1,1,NULL);
  SetViewportExtEx(hMemDest, 1,-1,NULL);
  SetWindowOrgEx(hMemDest, 0, height-1,NULL);

   // Step 4: Copy the pixels from the source to the destination.
  int current_pixel=0;
  for (int y=0;y<height;y++) { //0 to max height of bitmap
	for(int x=0;x<width;x++) { //0 to max width of bitmap
       current_pixel=GetPixel(hMemSrc,x,y); //get current pixel color
        if (current_pixel==BLACK) { //Set Target Transparent color (i.e. LTGREEN) to BLACK
	      SetPixel(hMemDest, x, y, sprite_color);
        } else if (current_pixel==background_color){
	      SetPixel(hMemDest, x, y, BLACK);
        } else {
          SetPixel(hMemDest, x, y, current_pixel);
        }
    }
  }

 // Step 5: Destroy the DCs.
  //DeleteObject(SelectObject(hMemSrc, hOldSourceBitmap));
  //DeleteObject(SelectObject(hMemDest, hOldDestBitmap));
  SelectObject(hMemSrc, hOldSourceBitmap);
  SelectObject(hMemDest, hOldDestBitmap);
  DeleteObject(hOldSourceBitmap);
  DeleteObject(hOldDestBitmap);
  DeleteDC(hMemDest);
  DeleteDC(hMemSrc);
  return (hDestBitmap);
}*/

/*
void ReplaceColorSprite(HBITMAP hBitmap,COLORREF old_color,COLORREF new_color)
{
  BITMAP bm;
  HDC hdc;
  BYTE* pixels;
  int data_size;
  GetObject(hBitmap,sizeof(bm),&bm);

  //create buffer to hold the pixel
  data_size = bm.bmWidth * bm.bmHeight * (bm.bmBitsPixel/8);
  pixels = (BYTE*) malloc(data_size);

  hdc=GetDC(NULL);
  GetDIBits(hdc, hBitmap,0,bm.bmHeight,pixels,(BITMAPINFO*)&bm,DIB_RGB_COLORS);

  //iterate thru pixels & replace color
  for (int i=0;i<data_size;i+=4) {
    COLORREF color = RGB(pixels[i+2],pixels[i+1],pixels[i]);
    if (color==old_color) {
      pixels[i]=GetBValue(new_color);
      pixels[i+1]=GetGValue(new_color);
      pixels[i+2]=GetRValue(new_color);
    }
  }

  SetDIBits(hdc,hBitmap,0,bm.bmHeight,pixels,(BITMAPINFO*)&bm,DIB_RGB_COLORS);
  ReleaseDC(NULL,hdc);
  free(pixels);
}*/

void ReplaceColorSprite(HBITMAP hBitmap, COLORREF oldColor, COLORREF newColor) 
{ 
  BITMAP bitmap; 
  GetObject(hBitmap, sizeof(BITMAP), &bitmap); 
  HDC hdc = CreateCompatibleDC(NULL); 
  SelectObject(hdc, hBitmap); 
  for (int y = 0; y < bitmap.bmHeight; y++) { 
    for (int x = 0; x < bitmap.bmWidth; x++) { 
      COLORREF color = GetPixel(hdc, x, y); 
      if (color == oldColor) { 
        SetPixel(hdc, x, y, newColor); 
      } 
    } 
  } 
  DeleteDC(hdc);
}



HBITMAP RotateSprite(HDC hDC, HBITMAP hSourceBitmap, double radians,int rTransparent, int old_color, int sprite_color, int sprite_color_2) 
{ //if (hSourceBitmap != NULL) { ////https://ftp.zx.net.nz/pub/Patches/ftp.microsoft.com/MISC/KB/en-us/77/127.HTM
  HBITMAP hOldSourceBitmap, hOldDestBitmap, hDestBitmap; ////https://www.codeguru.com/multimedia/rotate-a-bitmap-image/
  HDC hMemSrc,hMemDest;
  BITMAP iSrcBitmap;

  // Step 1: Create a memory DC for the source and destination bitmaps
  //         compatible with the device used.
  hMemSrc = CreateCompatibleDC(hDC);
  hMemDest= CreateCompatibleDC(hDC);


  // Step 2: Get the height and width of the source bitmap.
  GetObject(hSourceBitmap, sizeof(BITMAP), (LPSTR)&iSrcBitmap);

  // Get logical coordinates
  double cosine = (double)cos(radians);
  double sine = (double)sin(radians);

  // Compute dimensions of the resulting bitmap
  // First get the coordinates of the 3 corners other than origin
  int x1 = (int)(-iSrcBitmap.bmHeight * sine);
  int y1 = (int)(iSrcBitmap.bmHeight * cosine);
  int x2 = (int)(iSrcBitmap.bmWidth * cosine - iSrcBitmap.bmHeight * sine);
  int y2 = (int)(iSrcBitmap.bmHeight * cosine + iSrcBitmap.bmWidth * sine);
  int x3 = (int)(iSrcBitmap.bmWidth * cosine);
  int y3 = (int)(iSrcBitmap.bmWidth * sine);

  int minx = min(0,min(x1, min(x2,x3)));
  int miny = min(0,min(y1, min(y2,y3)));
  int maxx = max(0,max(x1, max(x2,x3)));
  int maxy = max(0, max(y1, max(y2,y3)));

  int width = maxx - minx;
  int height = maxy - miny;

  /*if (iSrcBitmap.bmHeight!=iSrcBitmap.bmWidth) {
    maxx=minx+iSrcBitmap.bmWidth;
    printf("w:%d\n",iSrcBitmap.bmWidth);
    printf("h:%d\n",iSrcBitmap.bmHeight);
  }*/

   // Step 3: Select the source bitmap into the source DC. Create a
   //         destination bitmap, and select it into the destination DC.

   //hDestBitmap = NULL;//CreateCompatibleBitmap(hMemDest, width, height);
  /*hDestBitmap = CreateBitmap(height, width, iSrcBitmap.bmPlanes,
                  iSrcBitmap.bmBitsPixel, NULL);*/

  hDestBitmap = CreateCrunchyBitmap(width,height);//CreateLargeBitmap(height, width);
  hOldSourceBitmap = SelectObject(hMemSrc, hSourceBitmap);
  hOldDestBitmap = SelectObject(hMemDest, hDestBitmap);

  // Set mapping mode so that +ve y axis is upwords
  SetMapMode(hMemSrc, MM_ISOTROPIC);
  SetWindowExtEx(hMemSrc, 1,1,NULL);
  SetViewportExtEx(hMemSrc, 1,-1,NULL);
  SetViewportOrgEx(hMemSrc, 0, iSrcBitmap.bmHeight-1,NULL);

  SetMapMode(hMemDest, MM_ISOTROPIC);
  SetWindowExtEx(hMemDest, 1,1,NULL);
  SetViewportExtEx(hMemDest, 1,-1,NULL);
  SetWindowOrgEx(hMemDest, minx, maxy-1,NULL);

   // Step 4: Copy the pixels from the source to the destination.
  int current_pixel=0;
  for (int y=miny;y<maxy;y++) { //0 to max height of bitmap
	for(int x=minx;x<maxx;x++) { //0 to max width of bitmap
	  int sourcex = (int)(x*cosine+y*sine); //get pixel from sprite, x-axis
	  int sourcey = (int)(y*cosine-x*sine); //get pixel from sprite, y-axis
      /*if (iSrcBitmap.bmHeight!=iSrcBitmap.bmWidth) {
        sourcex=x;
        sourcey=y;
      }*/
	  if(sourcex>=0 && sourcex<iSrcBitmap.bmWidth && sourcey>=0
	   	 && sourcey<iSrcBitmap.bmHeight ) {
         current_pixel=GetPixel(hMemSrc,sourcex,sourcey); //get current pixel color
        if (current_pixel==rTransparent) { //Set Target Transparent color (i.e. LTGREEN) to BLACK
	      SetPixel(hMemDest, x, y, BLACK);
        } else if (current_pixel==old_color){
          if (sprite_color_2==-1) { //custom flag to disallow dithreing
            if (sprite_color!=BLACK) { //Set BLACK to Custom Color
	          SetPixel(hMemDest, x, y, sprite_color);
            } else { //change BLACK to DKBLACK 
	          SetPixel(hMemDest, x, y, DKBLACK);
            }
          } else { //dither == old_color does not matter (for now) (im lazy)
            if (sprite_color!=BLACK) { //Set BLACK to Custom Color
              if (y%2==0) {
                if (x%2==0) {
	              SetPixel(hMemDest, x, y, sprite_color_2);
                } else {
	              SetPixel(hMemDest, x, y, sprite_color);
                }
              } else {
                if (x%2!=0) {
	              SetPixel(hMemDest, x, y, sprite_color_2);
                } else {
	              SetPixel(hMemDest, x, y, sprite_color);
                }
              }
            } else { //change BLACK to DKBLACK 
	          SetPixel(hMemDest, x, y, DKBLACK);
            }
          }
        } else {
          SetPixel(hMemDest, x, y, current_pixel);
        }
      }
    }
  }

 // Step 5: Destroy the DCs.
  //DeleteObject(SelectObject(hMemSrc, hOldSourceBitmap));
  //DeleteObject(SelectObject(hMemDest, hOldDestBitmap));
  SelectObject(hMemSrc, hOldSourceBitmap);
  SelectObject(hMemDest, hOldDestBitmap);
  DeleteObject(hOldSourceBitmap);
  DeleteObject(hOldDestBitmap);
  DeleteDC(hMemDest);
  DeleteDC(hMemSrc);
  return (hDestBitmap);
}



void DrawTriFill(HDC hdc, int tri_color, double x1,double y1,double x2,double y2,double x3,double y3,bool IsHatch,int hatch_type)
{//https://stackoverflow.com/questions/33447305/c-windows32-gdi-fill-triangle
  HPEN hPen = CreatePen(PS_SOLID, 2, tri_color);
  HPEN hOldPen = SelectObject(hdc, hPen);

  HBRUSH hBrush, hOldBrush;
  POINT vertices[] = { {x1, y1}, {x2, y2}, {x3, y3} };

  if (!IsHatch) {
    hBrush=CreateSolidBrush(tri_color);
    hOldBrush = SelectObject(hdc, hBrush);
  } else {
 // Set background mode to transparent 
    SetBkMode(hdc, TRANSPARENT);

    hBrush=CreateHatchBrush(hatch_type,tri_color);
    hOldBrush = SelectObject(hdc, hBrush);
  }  

  Polygon(hdc, vertices, sizeof(vertices) / sizeof(vertices[0]));

  SelectObject(hdc, hOldBrush);
  DeleteObject(hBrush);

  SelectObject(hdc, hOldPen);
  DeleteObject(hPen);
}


//https://learn.microsoft.com/en-us/windows/win32/gdi/drawing-a-shaded-triangle
/*void DrawGlassTriFill(HDC hdc, int tri_color,double x1,double y1,double x2,double y2,double x3,double y3,BYTE alpha)
{//https://stackoverflow.com/questions/33447305/c-windows32-gdi-fill-triangle
    BLENDFUNCTION blendFunction;
    blendFunction.BlendOp = AC_SRC_OVER;
    blendFunction.BlendFlags = 0;
    blendFunction.SourceConstantAlpha = alpha; // Transparency level (0-255)
    blendFunction.AlphaFormat = 0;

    HDC hdcMem = CreateCompatibleDC(hdc);
    HBITMAP hBitmap = CreateCompatibleBitmap(hdc, width, height);
    SelectObject(hdcMem, hBitmap);

    // Fill the rectangle with the desired color
    HBRUSH hBrush = CreateSolidBrush(COLOR); // Blue color
    RECT rect = {x, y, width, height};
    FillRect(hdcMem, &rect, hBrush);

    // Use AlphaBlend to draw the transparent rectangle
    AlphaBlend(hdc, 0, 0, width, height, hdcMem, 0, 0, width, height, blendFunction);

    // Clean up
    DeleteObject(hBrush);
    DeleteObject(hBitmap);
    DeleteDC(hdcMem);
*/
/*    BLENDFUNCTION blendFunction;
    blendFunction.BlendOp = AC_SRC_OVER;
    blendFunction.BlendFlags = 0;
    blendFunction.SourceConstantAlpha = alpha; // Transparency level (0-255)
    blendFunction.AlphaFormat = 0;


    int lowest_x=min(x1,min(x2,x3));
    int lowest_y=min(y1,min(y2,y3));
    int highest_x=max(x1,max(x2,x3));
    int highest_y=max(y1,max(y2,y3));
    int width=highest_x-lowest_x;
    int height=highest_y-lowest_y;

    HDC hdcMem = CreateCompatibleDC(hdc);
    HBITMAP hBitmap = CreateCompatibleBitmap(hdc, width, height);
    SelectObject(hdcMem, hBitmap);

    /*HPEN hPen = CreatePen(PS_SOLID, 2, tri_color);
    HPEN hOldPen = SelectObject(hdcMem, hPen);

    HBRUSH hBrush = CreateSolidBrush(tri_color);
    HBRUSH hOldBrush = SelectObject(hdcMem, hBrush);*/


    /*POINT vertices[] = { {x1, y1}, {x2, y2}, {x3, y3} };
    Polygon(hdc, vertices, sizeof(vertices) / sizeof(vertices[0]));*/
    /*HBRUSH hBrush = CreateSolidBrush(tri_color);
    RECT rect = {lowest_x, lowest_y, width, height};
    FillRect(hdcMem, &rect, hBrush);

    AlphaBlend(hdc, lowest_x, lowest_y, width, height, hdcMem, 0, 0, width, height, blendFunction);

    
    // Use AlphaBlend to draw the transparent rectangle
    //AlphaBlend(hdc, lowest_x,lowest_y, width, height, hdcMem, 0, 0, width, height, blendFunction);


    /*SelectObject(hdcMem, hOldBrush);
    DeleteObject(hBrush);

    SelectObject(hdcMem, hOldPen);
    DeleteObject(hPen);*/

    // Clean up
/*    DeleteObject(hBrush);
    //DeleteObject(hBitmap);
    //DeleteDC(hdcMem);
}*/


/*
#include <windows.h>

void DrawTransparentTriangle(HDC hdc) {
    // Define the vertices of the triangle
    POINT vertices[] = { {100, 50}, {150, 150}, {50, 150} };

    // Create a solid brush with transparency (50% transparent red)
    HBRUSH hBrush = CreateSolidBrush(RGB(255, 0, 0) | 0x80000000);
    HBRUSH hOldBrush = (HBRUSH)SelectObject(hdc, hBrush);

    // Draw the triangle
    Polygon(hdc, vertices, 3);

    // Clean up
    SelectObject(hdc, hOldBrush);
    DeleteObject(hBrush);
}

*/

//https://stackoverflow.com/questions/3142349/drawing-on-8bpp-grayscale-bitmap-unmanaged-c
HBITMAP CreateGreyscaleBitmap(int cx, int cy)
{
  BITMAPINFO* pbmi = (BITMAPINFO*)alloca(offsetof(BITMAPINFO, bmiColors[256]));
  pbmi->bmiHeader.biSize = sizeof (pbmi->bmiHeader);
  pbmi->bmiHeader.biWidth = cx;
  pbmi->bmiHeader.biHeight = cy;
  pbmi->bmiHeader.biPlanes = 1;
  pbmi->bmiHeader.biBitCount = 8;
  pbmi->bmiHeader.biCompression = BI_RGB;
  pbmi->bmiHeader.biSizeImage = 0;
  pbmi->bmiHeader.biXPelsPerMeter = 14173;
  pbmi->bmiHeader.biYPelsPerMeter = 14173;
  pbmi->bmiHeader.biClrUsed = 0;
  pbmi->bmiHeader.biClrImportant = 0;

  for(int i=0; i<256; i++)
  {
    pbmi->bmiColors[i].rgbRed = i;
    pbmi->bmiColors[i].rgbGreen = i;
    pbmi->bmiColors[i].rgbBlue = i;
    pbmi->bmiColors[i].rgbReserved = 0;
  }

  PVOID pv;
  return CreateDIBSection(NULL,pbmi,DIB_RGB_COLORS,&pv,NULL,0);
}


void CopyPartialGreyscaleBitmap(HBITMAP dBitmap, HBITMAP sBitmap,int x,int SRCOPERATION)
{

  BITMAP bm;
  GetObject(sBitmap, sizeof(bm), &bm);

  HDC hdc1=CreateCompatibleDC(NULL);
  HDC hdc2=CreateCompatibleDC(NULL);
  SelectObject(hdc2,sBitmap);
  SelectObject(hdc1,dBitmap);
  BitBlt(hdc1, 0, 0, x, bm.bmHeight, hdc2, 0, 0, SRCOPERATION);
  DeleteDC(hdc2);
  DeleteDC(hdc1);
}


HBITMAP CopyGreyscaleBitmap(HBITMAP sBitmap, int SRCOPERATION)
{
  BITMAP bm;
  GetObject(sBitmap, sizeof(bm), &bm);

  BITMAPINFO* pbmi = (BITMAPINFO*)alloca(offsetof(BITMAPINFO, bmiColors[256]));
  pbmi->bmiHeader.biSize = sizeof (pbmi->bmiHeader);
  pbmi->bmiHeader.biWidth = bm.bmWidth;
  pbmi->bmiHeader.biHeight = bm.bmHeight;
  pbmi->bmiHeader.biPlanes = 1;
  pbmi->bmiHeader.biBitCount = 8;
  pbmi->bmiHeader.biCompression = BI_RGB;
  pbmi->bmiHeader.biSizeImage = 0;
  pbmi->bmiHeader.biXPelsPerMeter = 14173;
  pbmi->bmiHeader.biYPelsPerMeter = 14173;
  pbmi->bmiHeader.biClrUsed = 0;
  pbmi->bmiHeader.biClrImportant = 0;

  for(int i=0; i<256; i++)
  {
    pbmi->bmiColors[i].rgbRed = i;
    pbmi->bmiColors[i].rgbGreen = i;
    pbmi->bmiColors[i].rgbBlue = i;
    pbmi->bmiColors[i].rgbReserved = 0;
  }

  PVOID pv;
  HDC hdc=CreateCompatibleDC(NULL);
  HDC hdc2=CreateCompatibleDC(NULL);
  HBITMAP dBitmap=CreateDIBSection(NULL,pbmi,DIB_RGB_COLORS,&pv,NULL,0);
  SelectObject(hdc2,sBitmap);
  SelectObject(hdc,dBitmap);
  BitBlt(hdc, 0, 0, bm.bmWidth, bm.bmHeight, hdc2, 0, 0, SRCOPERATION);
  DeleteDC(hdc2);
  DeleteDC(hdc);
  return dBitmap;
}


HBITMAP CopyBitmap(HBITMAP srcBitmap,int SRCOPERATION)
{
  BITMAP bm;
  GetObject(srcBitmap, sizeof(bm), &bm);
  HBITMAP destBitmap=CreateLargeBitmap(bm.bmWidth,bm.bmHeight);

  HDC hdcMem = CreateCompatibleDC(NULL);
  HDC hdcMem2 = CreateCompatibleDC(NULL);

  SelectObject(hdcMem2, srcBitmap);
  SelectObject(hdcMem, destBitmap);

  BitBlt(hdcMem, 0, 0, bm.bmWidth, bm.bmHeight, hdcMem2, 0, 0, SRCOPERATION);

  DeleteDC(hdcMem);
  DeleteDC(hdcMem2);

  return destBitmap;
}



HBITMAP CopyCrunchyBitmap(HBITMAP srcBitmap,int SRCOPERATION)
{
  BITMAP bm;
  GetObject(srcBitmap, sizeof(bm), &bm);
  HBITMAP destBitmap=CreateCrunchyBitmap(bm.bmWidth,bm.bmHeight);

  HDC hdcMem = CreateCompatibleDC(NULL);
  HDC hdcMem2 = CreateCompatibleDC(NULL);

  SelectObject(hdcMem2, srcBitmap);
  SelectObject(hdcMem, destBitmap);

  BitBlt(hdcMem, 0, 0, bm.bmWidth, bm.bmHeight, hdcMem2, 0, 0, SRCOPERATION);

  DeleteDC(hdcMem);
  DeleteDC(hdcMem2);

  return destBitmap;
}




HBITMAP CopyStretchBitmap(HBITMAP srcBitmap,int SRCOPERATION, int nWidth, int nHeight)
{
  BITMAP bm;
  GetObject(srcBitmap, sizeof(bm), &bm);

  HBITMAP destBitmap=CreateLargeBitmap(nWidth,nHeight);

  HDC hdcMem = CreateCompatibleDC(NULL);
  HDC hdcMem2 = CreateCompatibleDC(NULL);

  SelectObject(hdcMem2, srcBitmap);
  SelectObject(hdcMem, destBitmap);

  StretchBlt(hdcMem, 0, 0, nWidth, nHeight, hdcMem2, 0,0, bm.bmWidth, bm.bmHeight, SRCOPERATION); //draw to 

  DeleteDC(hdcMem);
  DeleteDC(hdcMem2);

  return destBitmap;
}



void DrawPaletteSquare(HDC hdc,int move_x,int move_y)
{
  int size=8;
  int index=0;
  for (int y=0;y<16;y++) { //up to down 
    for (int x=0;x<16;x++) { //left to right
      GrRect(hdc,move_x+x*size,move_y+y*size,size,size,RGB(rgbColorsDefault[index].rgbRed,rgbColorsDefault[index].rgbGreen,rgbColorsDefault[index].rgbBlue));
      index++;
    }
  }
}


void DrawPaintSquare(HDC hdc,int move_x,int move_y,int original_index, int target_index)
{
  const int size=8;
  const int size2=12;
  int index=0;
  for (int y=0;y<16;y++) { //up to down 
    for (int x=0;x<16;x++) { //left to right
      if (index==target_index) {
        GrRect(hdc,move_x+x*size-2,move_y+y*size-2,size2,size2,WHITE);        
        GrRect(hdc,move_x+x*size,move_y+y*size,size,size,rgbPaint[index]);
      } else {
        GrCircle(hdc,move_x+x*size+4,move_y+y*size+4,4,rgbPaint[index],rgbPaint[index]);
      }
      //GrRect(hdc,move_x+x*size,move_y+y*size,size,size,rgbPaint[index]);
      if (index==original_index) {
        GrCircle(hdc,move_x+x*size+4,move_y+y*size+4,2,WHITE,WHITE);
       }
      index++;
    }
  }
}


//GrSprite Deprecated
/*
void GrSprite(HDC hDC,double _x1,double _y1, HBITMAP hSourceBitmap,bool is_left) {
  if (hSourceBitmap != NULL) { ////https://ftp.zx.net.nz/pub/Patches/ftp.microsoft.com/MISC/KB/en-us/77/127.HTM
    //BITMAP bm;
    //GetObject(hSourceBitmap, sizeof(bm), &bm);

    static HBITMAP hBitmap;
    BITMAP bm;

    /*HBITMAP hOldSourceBitmap, hOldDestBitmap; ////https://www.codeguru.com/multimedia/rotate-a-bitmap-image/
    HDC hMemSrc,hMemDest;
    hMemSrc = CreateCompatibleDC(hDC);
    hMemDest = CreateCompatibleDC(hDC);*/


    //GetObject(hSourceBitmap, sizeof(bm), &bm);


    /*hBitmap = CreateBitmap(bm.bmWidth, bm.bmHeight, 
                        bm.bmPlanes, bm.bmBitsPixel, //IMPORTANT, these 2 arguements allow color to pass through
                        NULL); */
    /*hBitmap = CreateCrunchyBitmap(bm.bmWidth,bm.bmHeight);//CreateLargeBitmap(bm.bmWidth,bm.bmHeight);
    hOldSourceBitmap = SelectObject(hMemSrc, hSourceBitmap);
    hOldDestBitmap = SelectObject(hMemDest, hBitmap);

    BitBlt(hMemDest, 0, 0, bm.bmWidth, bm.bmHeight, hMemSrc, 0, 0, SRCCOPY);

    SelectObject(hMemSrc, hOldSourceBitmap);
    SelectObject(hMemDest, hOldDestBitmap);
    DeleteDC(hMemDest);
    DeleteDC(hMemSrc);*/
    //hBitmap = CopyCrunchyBitmap(hSourceBitmap, IMAGE_BITMAP, 0,0, LR_DEFAULTSIZE); //causes memleak

/*
    hBitmap=CopyCrunchyBitmap(hSourceBitmap,SRCCOPY);
    HBITMAP hBitmapMask=CreateBitmapMask(hBitmap,BLACK,NULL);

     

    //====================Begin Bitmapmask Creation
    /*static HBITMAP hBitmapMask;
    HDC hdcMem1, hdcMem2;

    // Create monochrome (1 bit) mask bitmap.  

    GetObject(hBitmap, sizeof(bm), &bm);
    hBitmapMask = CreateBitmap(bm.bmWidth, bm.bmHeight, 1, 1, NULL);

    // Get some HDCs that are compatible with the display driver

    hdcMem1 = CreateCompatibleDC(hDC);
    hdcMem2 = CreateCompatibleDC(hDC);

    SelectObject(hdcMem1, hBitmap);
    SelectObject(hdcMem2, hBitmapMask);

    // Set the background colour of the colour image to the colour
    // you want to be transparent.
    SetBkColor(hdcMem1, BLACK);

    // Copy the bits from the colour image to the B+W mask... everything
    // with the background colour ends up white while everythig else ends up
    // black...Just what we wanted.

    BitBlt(hdcMem2, 0, 0, bm.bmWidth, bm.bmHeight, hdcMem1, 0, 0, SRCCOPY);

    // Take our new mask and use it to turn the transparent colour in our
    // original colour image to black so the transparency effect will
    // work right.
    BitBlt(hdcMem1, 0, 0, bm.bmWidth, bm.bmHeight, hdcMem2, 0, 0, SRCINVERT);

    // Clean up.

    DeleteDC(hdcMem1);
    DeleteDC(hdcMem2);
    //==================End of Bitmap Map Creation


    /* Causes Memleak
    HBITMAP hDestBitmapCopy = CopyImage(hDestBitmap, IMAGE_BITMAP, 0,0, LR_DEFAULTSIZE);
    HDC hdcMem2 = CreateCompatibleDC(hdcMem);
    static HBITMAP hBitmapMask;
    hBitmapMask = CreateBitmapMask(hDestBitmapCopy, BLACK, hdcMem);*/
/*
    HBITMAP oldbitmap,oldbitmap2;
    BITMAP bitmap;
    HDC hdcMemA = CreateCompatibleDC(hDC);
    HDC hdcMemB = CreateCompatibleDC(hDC);
    GetObject(hBitmapMask, sizeof(BITMAP), &bitmap);

    oldbitmap = SelectObject(hdcMemA, hBitmapMask);
    if (is_left) { //Flip Horizontally (X)
      StretchBlt(hDC, _x1+bitmap.bmWidth/2, _y1-bitmap.bmHeight/2, -bitmap.bmWidth-1, bitmap.bmHeight, hdcMemA, 0,0, bitmap.bmWidth, bitmap.bmHeight, SRCAND); //Create Mask for
    } else { //Regular
      //StretchBlt(hDC, _x1-bitmap.bmWidth/2, _y1-bitmap.bmHeight/2, bitmap.bmWidth, bitmap.bmHeight, hdcMemA, 0,0, bitmap.bmWidth, bitmap.bmHeight, SRCAND); //Create Mask for
      BitBlt(hDC, _x1-bitmap.bmWidth/2, _y1-bitmap.bmHeight/2, bitmap.bmWidth, bitmap.bmHeight, hdcMemA, 0,0, SRCAND); //no time wasted stretching
    }

    //GetObject(hBitmap, sizeof(BITMAP), &bitmap);
    oldbitmap2 = SelectObject(hdcMemB,hBitmap);
    if (is_left) { //Flip Horizontally (X)
      StretchBlt(hDC, _x1+bitmap.bmWidth/2, _y1-bitmap.bmHeight/2, -bitmap.bmWidth-1, bitmap.bmHeight, hdcMemB, 0,0, bitmap.bmWidth, bitmap.bmHeight, SRCPAINT); //Create Mask for
    } else { //Regular
      //StretchBlt(hDC, _x1-bitmap.bmWidth/2, _y1-bitmap.bmHeight/2, bitmap.bmWidth, bitmap.bmHeight, hdcMemB, 0,0, bitmap.bmWidth, bitmap.bmHeight, SRCPAINT); //Create Mask for
      BitBlt(hDC, _x1-bitmap.bmWidth/2, _y1-bitmap.bmHeight/2, bitmap.bmWidth, bitmap.bmHeight, hdcMemB, 0, 0, SRCPAINT); //no timew wasted stretching
    }
    //BitBlt(hDC, _x1-bitmap.bmWidth/2, _y1-bitmap.bmHeight, bitmap.bmWidth, bitmap.bmHeight, hdcMem, 0, 0, SRCAND); //This works (Demo, no flip transparent background)

    // DeleteObject(SelectObject(hdcMem, hBitmapMask));
    //https://learn.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-createcompatiblebitmap https://learn.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-deleteobject
    DeleteObject(SelectObject(hdcMemB, oldbitmap2));
    DeleteObject(SelectObject(hdcMemA, oldbitmap)); //https://learn.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-createcompatiblebitmap https://learn.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-deleteobject
    DeleteDC(hdcMemA);
    DeleteDC(hdcMemB);
    DeleteObject(hBitmap);

/*  DrawBitmap(hDC,
                 _x1,
                 _y1,
                 0,//-player.cam_mouse_move_x-player.cam_move_x-GR_WIDTH/2,
                 0,//player.y-player.cam_mouse_move_y-player.cam_move_y-GR_HEIGHT/2,
                 bm.bmWidth,
                 bm.bmHeight,
                 hSourceBitmap,SRCAND,FALSE);
  DrawBitmap(hDC,
                 _x1,
                 _y1,
                 0,//-player.cam_mouse_move_x-player.cam_move_x-GR_WIDTH/2,
                 0,//player.y-player.cam_mouse_move_y-player.cam_move_y-GR_HEIGHT/2,
                 bm.bmWidth,
                 bm.bmHeight,
                 hSourceBitmap,SRCPAINT,FALSE);*/
/*  } else {
    GrPrint(hDC,_x1,_y1,"(No Sprite)",WHITE); //Print Message if sprite cannot be loaded
  }
}*/



typedef struct DRAWSPRITE
{
  HBITMAP sprite_mask;
  HBITMAP sprite_paint;
} DRAWSPRITE;



void GenerateDrawSprite(DRAWSPRITE* myDrawSprite,HBITMAP srcBitmap)
{
    myDrawSprite->sprite_paint=CopyCrunchyBitmap(srcBitmap,SRCCOPY);
    myDrawSprite->sprite_mask=CreateBitmapMask(myDrawSprite->sprite_paint,BLACK,NULL);
}



void FreeDrawSprite(DRAWSPRITE* myDrawSprite)
{
  if (myDrawSprite->sprite_mask!=NULL)
    DeleteObject(myDrawSprite->sprite_mask);
  if (myDrawSprite->sprite_paint!=NULL)
    DeleteObject(myDrawSprite->sprite_paint);
}



void DrawSprite(HDC hdc,HDC hdc2,int _x1, int _y1, DRAWSPRITE* myDrawSprite,bool is_left)
{
  BITMAP bm;
  GetObject(myDrawSprite->sprite_mask, sizeof(bm), &bm);

  DrawBitmap(hdc,hdc2,
                 _x1-bm.bmWidth/2,
                 _y1-bm.bmHeight/2,
                 0,
                 0,
                 bm.bmWidth,
                 bm.bmHeight,
                 myDrawSprite->sprite_mask,SRCAND,FALSE,is_left);
  DrawBitmap(hdc,hdc2,
                 _x1-bm.bmWidth/2,
                 _y1-bm.bmHeight/2,
                 0,
                 0,
                 bm.bmWidth,
                 bm.bmHeight,
                 myDrawSprite->sprite_paint,SRCPAINT,FALSE,is_left);

}


/*void GrGlassPixel(HDC hdc, int x, int y, COLORREF color, BYTE alpha) {
    // Create a memory DC and a bitmap
    HDC memDC = CreateCompatibleDC(hdc);
    HBITMAP hBitmap = CreateCompatibleBitmap(hdc, 1, 1);
    SelectObject(memDC, hBitmap);

    // Set the pixel color
    SetPixel(memDC, 0, 0, color);

    // Create a BLENDFUNCTION structure
    BLENDFUNCTION blendFunc;
    blendFunc.BlendOp = AC_SRC_OVER;
    blendFunc.BlendFlags = 0;
    blendFunc.SourceConstantAlpha = alpha; // 50% transparency
    blendFunc.AlphaFormat = 0;

    // Use AlphaBlend to draw the pixel with transparency
    AlphaBlend(hdc, x, y, 1, 1, memDC, 0, 0, 1, 1, blendFunc);

    // Clean up
    DeleteObject(hBitmap);
    DeleteDC(memDC);
}*/

//Sprites must be 32-bit :/
void DrawGlassBitmap(HDC hdc, HBITMAP hBitmap, int x, int y, int level)
{
    // Create a memory device context compatible with the specified device context
    BITMAP bm;
    GetObject(hBitmap, sizeof(bm), &bm);
    int width = bm.bmWidth;
    int height = bm.bmHeight;

    HDC hdcMem = CreateCompatibleDC(hdc);
    //if (!hdcMem) return;

    // Select the bitmap into the memory device context
    HBITMAP hOldBitmap = (HBITMAP)SelectObject(hdcMem, hBitmap);

    // Set up the blend function
    BLENDFUNCTION blendFunc;
    blendFunc.BlendOp = AC_SRC_OVER;
    blendFunc.BlendFlags = 0;
    blendFunc.SourceConstantAlpha = level; // 50% transparency
    blendFunc.AlphaFormat = 0;//AC_SRC_ALPHA;//0;

    // Perform the alpha blending
    AlphaBlend(hdc, x, y, width, height, hdcMem, 0, 0, width, height, blendFunc);

    // Clean up
    SelectObject(hdcMem, hOldBitmap);
    DeleteDC(hdcMem);
}



/*void DrawTBitmap(HDC hdc,  DRAWSPRITE* myDrawSprite, int x, int y, int level,bool is_left)
{
    BITMAP bm;
    GetObject(myDrawSprite->sprite_mask, sizeof(bm), &bm);
    int width=bm.bmWidth;
    int height=bm.bmHeight;

    BLENDFUNCTION blendFunction;
    blendFunction.BlendOp = AC_SRC_OVER;
    blendFunction.BlendFlags = 0;
    blendFunction.SourceConstantAlpha = level;//alpha; // Transparency level (0-255),255 == not transparent
    blendFunction.AlphaFormat = AC_SRC_ALPHA;//0;

    HDC hdcMem = CreateCompatibleDC(hdc);
    HBITMAP hBitmap = CreateCompatibleBitmap(hdc, width, height);
    SelectObject(hdcMem, hBitmap);

    DrawSprite(hdcMem, width/2,height/2, myDrawSprite, is_left);

    // Use AlphaBlend to draw the transparent rectangle
    AlphaBlend(hdc, x-width/2, y-height/2, width, height, hdcMem, 0, 0, width, height, blendFunction);

    // Clean up
    DeleteObject(hBitmap);
    DeleteDC(hdcMem);

}

void DrawGlassSprite(HDC hdc,int _x1, int _y1, DRAWSPRITE* myDrawSprite,bool is_left) 
{
  DrawTBitmap(hdc,myDrawSprite,_x1,_y1,127,is_left);
}*/


/*
void BlendPixel(BYTE* dest, BYTE* src, BYTE alpha) {
    dest[0] = (src[0] * alpha + dest[0] * (255 - alpha)) / 255; // Blue
    dest[1] = (src[1] * alpha + dest[1] * (255 - alpha)) / 255; // Green
    dest[2] = (src[2] * alpha + dest[2] * (255 - alpha)) / 255; // Red
}

void DrawTransparentSprite(HDC hdc, HBITMAP hSprite, int x, int y, BYTE alpha) {
    BITMAP bm;
    GetObject(hSprite, sizeof(BITMAP), &bm);

    HDC hMemDC = CreateCompatibleDC(hdc);
    SelectObject(hMemDC, hSprite);

    BITMAPINFO bmi = {0};
    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth = bm.bmWidth;
    bmi.bmiHeader.biHeight = -bm.bmHeight; // Top-down
    bmi.bmiHeader.biPlanes = 1;
    bmi.bmiHeader.biBitCount = 24;
    bmi.bmiHeader.biCompression = BI_RGB;

    BYTE* pBits = (BYTE*)malloc(bm.bmWidth * bm.bmHeight * 3);
    GetDIBits(hMemDC, hSprite, 0, bm.bmHeight, pBits, &bmi, DIB_RGB_COLORS);

    for (int j = 0; j < bm.bmHeight; ++j) {
        for (int i = 0; i < bm.bmWidth; ++i) {
            COLORREF bgColor = GetPixel(hdc, x + i, y + j);
            BYTE bg[3] = { GetBValue(bgColor), GetGValue(bgColor), GetRValue(bgColor) };
            BYTE* src = &pBits[(j * bm.bmWidth + i) * 3];
            BlendPixel(bg, src, alpha);
            SetPixel(hdc, x + i, y + j, RGB(bg[2], bg[1], bg[0]));
        }
    }

    free(pBits);
    DeleteDC(hMemDC);
}*/



/*void BlendPixel(BYTE* dest, BYTE* src, BYTE alpha) {
    dest[0] = (src[0] * alpha + dest[0] * (255 - alpha)) / 255; // Blue
    dest[1] = (src[1] * alpha + dest[1] * (255 - alpha)) / 255; // Green
    dest[2] = (src[2] * alpha + dest[2] * (255 - alpha)) / 255; // Red
}

void DrawTransparentSprite(HDC hdc, HBITMAP hSprite, int x, int y, BYTE alpha) {
    BITMAP bm;
    GetObject(hSprite, sizeof(BITMAP), &bm);

    HDC hMemDC = CreateCompatibleDC(hdc);
    SelectObject(hMemDC, hSprite);

    BITMAPINFO bmi = {0};
    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth = bm.bmWidth;
    bmi.bmiHeader.biHeight = -bm.bmHeight; // Top-down
    bmi.bmiHeader.biPlanes = 1;
    bmi.bmiHeader.biBitCount = 24;
    bmi.bmiHeader.biCompression = BI_RGB;

    BYTE* pSpriteBits = (BYTE*)malloc(bm.bmWidth * bm.bmHeight * 3);
    GetDIBits(hMemDC, hSprite, 0, bm.bmHeight, pSpriteBits, &bmi, DIB_RGB_COLORS);

    HDC hMemDC2 = CreateCompatibleDC(hdc);
    HBITMAP hBackground = CreateCompatibleBitmap(hdc, bm.bmWidth, bm.bmHeight);
    SelectObject(hMemDC2, hBackground);
    BitBlt(hMemDC2, 0, 0, bm.bmWidth, bm.bmHeight, hdc, x, y, SRCCOPY);

    BYTE* pBackgroundBits = (BYTE*)malloc(bm.bmWidth * bm.bmHeight * 3);
    GetDIBits(hMemDC2, hBackground, 0, bm.bmHeight, pBackgroundBits, &bmi, DIB_RGB_COLORS);

    for (int j = 0; j < bm.bmHeight; ++j) {
        for (int i = 0; i < bm.bmWidth; ++i) {
            BYTE* bg = &pBackgroundBits[(j * bm.bmWidth + i) * 3];
            BYTE* src = &pSpriteBits[(j * bm.bmWidth + i) * 3];
            BlendPixel(bg, src, alpha);
        }
    }

    SetDIBits(hMemDC2, hBackground, 0, bm.bmHeight, pBackgroundBits, &bmi, DIB_RGB_COLORS);
    BitBlt(hdc, x, y, bm.bmWidth, bm.bmHeight, hMemDC2, 0, 0, SRCCOPY);

    free(pSpriteBits);
    free(pBackgroundBits);
    DeleteObject(hBackground);
    DeleteDC(hMemDC);
    DeleteDC(hMemDC2);
}

/*
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
    // Initialize and create window...

    HBITMAP hSprite = (HBITMAP)LoadImage(NULL, "sprite.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
    if (!hSprite) {
        MessageBox(NULL, "Failed to load sprite", "Error", MB_OK);
        return 0;
    }

    // In your window's paint handler:
    PAINTSTRUCT ps;
    HDC hdc = BeginPaint(hWnd, &ps);
    DrawTransparentSprite(hdc, hSprite, 50, 50, 128); // 50% transparency
    EndPaint(hWnd, &ps);

    // Cleanup and exit...
    DeleteObject(hSprite);
    return 0;
}*/


// Function to draw a transparent sprite
/*void DrawTransparentSprite(HDC hdcDest, int xDest, int yDest, HBITMAP hBitmap, int width, int height) {
    HDC hdcMem = CreateCompatibleDC(hdcDest);
    HBITMAP hOldBitmap = (HBITMAP)SelectObject(hdcMem, hBitmap);

    // Create a temporary bitmap to hold the modified image
    HBITMAP hTempBitmap = CreateCompatibleBitmap(hdcDest, width, height);
    HDC hdcTemp = CreateCompatibleDC(hdcDest);
    HBITMAP hOldTempBitmap = (HBITMAP)SelectObject(hdcTemp, hTempBitmap);

    // Copy the original image to the temporary bitmap
    BitBlt(hdcTemp, 0, 0, width, height, hdcMem, 0, 0, SRCCOPY);

    // Modify the pixels to achieve 50% transparency
    BITMAPINFO bmi;
    ZeroMemory(&bmi, sizeof(BITMAPINFO));
    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth = width;
    bmi.bmiHeader.biHeight = -height; // Negative to indicate top-down DIB
    bmi.bmiHeader.biPlanes = 1;
    bmi.bmiHeader.biBitCount = 32;
    bmi.bmiHeader.biCompression = BI_RGB;

    RGBQUAD* pPixels = (RGBQUAD*)malloc(width * height * sizeof(RGBQUAD));
    GetDIBits(hdcTemp, hTempBitmap, 0, height, pPixels, &bmi, DIB_RGB_COLORS);

    for (int i = 0; i < width * height; ++i) {
        pPixels[i].rgbReserved = (BYTE)(pPixels[i].rgbReserved * 0.5); // 50% transparency
    }

    SetDIBits(hdcTemp, hTempBitmap, 0, height, pPixels, &bmi, DIB_RGB_COLORS);
    free(pPixels);

    // Draw the modified image to the destination DC
    BitBlt(hdcDest, xDest, yDest, width, height, hdcTemp, 0, 0, SRCCOPY);

    // Cleanup
    SelectObject(hdcTemp, hOldTempBitmap);
    DeleteDC(hdcTemp);
    DeleteObject(hTempBitmap);
    SelectObject(hdcMem, hOldBitmap);
    DeleteDC(hdcMem);
}*/



//https://github.com/jroop6/SimpleKeylogger/blob/2a8fd44237a2ba85bcdb9b6bd05bec26ac2cd4f5/SimpleKeylogger/MainWindow.cpp
//https://github.com/MarySoroka/OSASP-2/blob/70c997b0f58a3a2886654fc97feaf82572038c95/Paint/Paint/paint.cpp


bool SaveLargeBitmapToFile(HBITMAP hBitmap, LPCWSTR lpszFileName) {
    BITMAP bmp;
    PBITMAPINFO pbmi;
    WORD cClrBits;
    HANDLE hf;                  // file handle
    BITMAPFILEHEADER hdr;       // bitmap file-header
    PBITMAPINFOHEADER pbih;     // bitmap info-header
    LPBYTE lpBits;              // memory pointer
    DWORD dwTotal;              // total count of bytes
    DWORD cb;                   // incremental count of bytes
    BYTE *hp;                   // byte pointer
    DWORD dwTmp;

    // Retrieve the bitmap color format, width, and height.
    if (!GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bmp)) {
        return FALSE;
    }

    // Convert the color format to a count of bits.
    cClrBits = (WORD)(bmp.bmPlanes * bmp.bmBitsPixel);
    if (cClrBits == 1) {
        cClrBits = 1;
    } else if (cClrBits <= 4) {
        cClrBits = 4;
    } else if (cClrBits <= 8) {
        cClrBits = 8;
    } else if (cClrBits <= 16) {
        cClrBits = 16;
    } else if (cClrBits <= 24) {
        cClrBits = 24;
    } else {
        cClrBits = 32;
    }

    // Allocate memory for the BITMAPINFO structure.
    if (cClrBits != 24) {
        pbmi = (PBITMAPINFO) LocalAlloc(LPTR, sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD) * (1 << cClrBits));
    } else {
        pbmi = (PBITMAPINFO) LocalAlloc(LPTR, sizeof(BITMAPINFOHEADER));
    }

    // Initialize the fields in the BITMAPINFO structure.
    pbih = (PBITMAPINFOHEADER) pbmi;
    pbih->biSize = sizeof(BITMAPINFOHEADER);
    pbih->biWidth = bmp.bmWidth;
    pbih->biHeight = bmp.bmHeight;
    pbih->biPlanes = bmp.bmPlanes;
    pbih->biBitCount = bmp.bmBitsPixel;
    if (cClrBits < 24) {
        pbih->biClrUsed = (1 << cClrBits);
    }

    // If the bitmap is not compressed, set the BI_RGB flag.
    pbih->biCompression = BI_RGB;

    // Compute the number of bytes in the array of color indices and store the result in biSizeImage.
    pbih->biSizeImage = ((pbih->biWidth * cClrBits + 31) & ~31) / 8 * pbih->biHeight;
    pbih->biClrImportant = 0;

    // Allocate memory for the array of color indices.
    lpBits = (LPBYTE) GlobalAlloc(GMEM_FIXED, pbih->biSizeImage);

    // Retrieve the color table (RGBQUAD array) and the bits (array of palette indices).
    if (!GetDIBits(GetDC(0), hBitmap, 0, (WORD) pbih->biHeight, lpBits, pbmi, DIB_RGB_COLORS)) {
        return FALSE;
    }

    // Create the .BMP file.
    hf = CreateFile(lpszFileName, GENERIC_READ | GENERIC_WRITE, (DWORD) 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE) NULL);
    if (hf == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    hdr.bfType = 0x4D42;  // "BM"
    hdr.bfSize = (DWORD) (sizeof(BITMAPFILEHEADER) + pbih->biSize + pbih->biClrUsed * sizeof(RGBQUAD) + pbih->biSizeImage);
    hdr.bfReserved1 = 0;
    hdr.bfReserved2 = 0;
    hdr.bfOffBits = (DWORD) sizeof(BITMAPFILEHEADER) + pbih->biSize + pbih->biClrUsed * sizeof (RGBQUAD);

    // Write the BITMAPFILEHEADER to the .BMP file.
    if (!WriteFile(hf, (LPVOID) &hdr, sizeof(BITMAPFILEHEADER), (LPDWORD) &dwTmp, NULL)) {
        return FALSE;
    }

    // Write the BITMAPINFOHEADER and RGBQUAD array to the file.
    if (!WriteFile(hf, (LPVOID) pbih, sizeof(BITMAPINFOHEADER) + pbih->biClrUsed * sizeof (RGBQUAD), (LPDWORD) &dwTmp, NULL)) {
        return FALSE;
    }

    // Copy the array of color indices into the .BMP file.
    dwTotal = cb = pbih->biSizeImage;
    hp = lpBits;
    if (!WriteFile(hf, (LPSTR) hp, (int) cb, (LPDWORD) &dwTmp, NULL)) {
        return FALSE;
    }

    // Close the .BMP file.
    if (!CloseHandle(hf)) {
        return FALSE;
    }

    // Free memory.
    GlobalFree((HGLOBAL)lpBits);
    LocalFree((HLOCAL)pbmi);

    return TRUE;
}


//DONT DELETE
void SaveBitmapToFile(HBITMAP hBitmap, RGBQUAD* palette, const wchar_t* filename) {
    BITMAP bmp;
    BITMAPINFOHEADER bi;
    BITMAPFILEHEADER bf;
    FILE* file;
    HDC hdc;

    // Get the bitmap information
    GetObject(hBitmap, sizeof(BITMAP), &bmp);

    // Initialize the bitmap info header
    bi.biSize = sizeof(BITMAPINFOHEADER);
    bi.biWidth = bmp.bmWidth;
    bi.biHeight = bmp.bmHeight;
    bi.biPlanes = 1;
    bi.biBitCount = 8;
    bi.biCompression = BI_RGB;
    bi.biSizeImage = bmp.bmWidth * bmp.bmHeight;
    bi.biXPelsPerMeter = 0;
    bi.biYPelsPerMeter = 0;
    bi.biClrUsed = 256;
    bi.biClrImportant = 256;

    // Initialize the bitmap file header
    bf.bfType = 0x4D42; // 'BM'
    bf.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD) * 256;
    bf.bfSize = bf.bfOffBits + bi.biSizeImage;
    bf.bfReserved1 = 0;
    bf.bfReserved2 = 0;

    // Open the file for writing
    file = _wfopen(filename, L"wb");
    if (!file) {
        printf("Error opening file for writing.\n");
        return;
    }

    // Write the file headers
    fwrite(&bf, sizeof(BITMAPFILEHEADER), 1, file);
    fwrite(&bi, sizeof(BITMAPINFOHEADER), 1, file);

    // Write the palette to the file
    fwrite(palette, sizeof(RGBQUAD), 256, file);

    // Write the bitmap bits to the file
    fwrite(bmp.bmBits, bi.biSizeImage, 1, file);

    // Close the file
    fclose(file);
    //printf("drawn\n");
}






void SaveBitmapToFile2(HBITMAP hBitmap, RGBQUAD* palette, const wchar_t* filename) {
    BITMAP bmp;
    BITMAPINFOHEADER bi;
    BITMAPFILEHEADER bf;
    FILE* file;
    BYTE* rleData;
    DWORD rleSize = 0;

    // Get the bitmap information
    GetObject(hBitmap, sizeof(BITMAP), &bmp);

    // Initialize the bitmap info header
    bi.biSize = sizeof(BITMAPINFOHEADER);
    bi.biWidth = bmp.bmWidth;
    bi.biHeight = bmp.bmHeight;
    bi.biPlanes = 1;
    bi.biBitCount = 8;
    bi.biCompression = BI_RLE8; // Use RLE compression
    bi.biSizeImage = 0; // Set to 0 for RLE compression
    bi.biXPelsPerMeter = 14173;
    bi.biYPelsPerMeter = 14173;
    bi.biClrUsed = 256;
    bi.biClrImportant = 256;

    // Initialize the bitmap file header
    bf.bfType = 0x4D42; // 'BM'
    bf.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD) * 256;
    bf.bfSize = bf.bfOffBits; // We'll add the RLE size later
    bf.bfReserved1 = 0;
    bf.bfReserved2 = 0;

    // Open the file for writing
    file = _wfopen(filename, L"wb");
    if (!file) {
        printf("Error opening file for writing.\n");
        return;
    }

    // Write the file headers
    fwrite(&bf, sizeof(BITMAPFILEHEADER), 1, file);
    fwrite(&bi, sizeof(BITMAPINFOHEADER), 1, file);

    // Write the palette to the file
    fwrite(palette, sizeof(RGBQUAD), 256, file);

    // Allocate memory for RLE data
    rleData = (BYTE*)malloc(bmp.bmWidth * bmp.bmHeight * 2); // Allocate enough memory for worst-case scenario

    // Encode the bitmap bits to RLE format
    BYTE* src = (BYTE*)bmp.bmBits;
    BYTE* dst = rleData;
    for (int y = 0; y < bmp.bmHeight; y++) {
        int x = 0;
        while (x < bmp.bmWidth) {
            BYTE count = 1;
            BYTE value = src[y * bmp.bmWidth + x];
            while (x + count < bmp.bmWidth && src[y * bmp.bmWidth + x + count] == value && count < 255) {
                count++;
            }
            *dst++ = count;
            *dst++ = value;
            x += count;
        }
        *dst++ = 0; // End of line
        *dst++ = 0;
    }
    rleSize = dst - rleData;

    // Update the size image field
    bi.biSizeImage = rleSize;

    // Write the RLE data to the file
    fwrite(rleData, rleSize, 1, file);

    // Update the file size in the file header
    bf.bfSize += rleSize;
    fseek(file, 0, SEEK_SET);
    fwrite(&bf, sizeof(BITMAPFILEHEADER), 1, file);
    fseek(file, sizeof(BITMAPFILEHEADER), SEEK_SET);
    fwrite(&bi, sizeof(BITMAPINFOHEADER), 1, file);

    // Close the file
    fclose(file);

    // Free the allocated memory
    free(rleData);
    //printf("drawn\n");
}





wchar_t *khnumtxt[10]={L"",L"",L"",L"",L"",L"",L"",L"",L"",L""};
wchar_t* ReplaceToKhmerNum(wchar_t* mytxt) 
{
  int len=wcslen(mytxt);
  for (int i=0;i<len;i++) {
    int c = mytxt[i];
    if ('0'<=c && c<='9') {
      mytxt[i]=khnumtxt[c-'0'][0];
    }
  }
  return mytxt;
}













int global_frames=0;
int iNumFrames=0;
HBITMAP global_avi_bitmap1;
HBITMAP global_avi_bitmap2;


PAVIFILE avi;
AVIFILEINFO avi_info;
PAVISTREAM pStream;
int res;
BITMAPINFOHEADER bih;
int iNumFrames;
int iFirstFrame;
PGETFRAME pFrame;


void DrawMovingAVI(HDC hdc,HDC hdc2) 
{
    if (global_frames%2==0) {
      DrawBitmap(hdc,hdc2,0,0,0,0,GR_WIDTH,GR_HEIGHT,global_avi_bitmap2,SRCCOPY,TRUE,FALSE);
    } else {
      DrawBitmap(hdc,hdc2,0,0,0,0,GR_WIDTH,GR_HEIGHT,global_avi_bitmap1,SRCCOPY,TRUE,FALSE);
    }
}

HBITMAP CreateFromPackedDIBPointer2(LPBYTE pDIB)
{
    /*if (pDIB == NULL)
    {
        return NULL;
    }*/

    // The BITMAPINFOHEADER is at the start of the DIB
    BITMAPINFOHEADER* _bih = (BITMAPINFOHEADER*)pDIB;

    // The pixel data starts immediately after the BITMAPINFOHEADER
    BYTE* _pPixels = pDIB + sizeof(BITMAPINFOHEADER);

    // Create a device context
    HDC hdc = GetDC(NULL);

    // Create a bitmap from the DIB
    HBITMAP hBitmap = CreateDIBitmap(hdc, _bih, CBM_INIT, _pPixels, (BITMAPINFO*)_bih, DIB_RGB_COLORS);

    // Release the device context
    ReleaseDC(NULL, hdc);
    return hBitmap;
}


bool InitExtractAVIFrames(const wchar_t* szFileName,int index)
{
    AVIFileInit();
    res=AVIFileOpen(&avi, szFileName, OF_READ, NULL);
    AVIFileInfo(avi, &avi_info, sizeof(AVIFILEINFO));
    res=AVIFileGetStream(avi, &pStream, streamtypeVIDEO /*video stream*/, 
                                               0 /*first stream*/);

    //do some task with the stream

    //iFirstFrame=AVIStreamStart(pStream);
    iNumFrames=AVIStreamLength(pStream);

    //getting bitmap from frame
    ZeroMemory(&bih, sizeof(BITMAPINFOHEADER));

    bih.biBitCount=8;    //24 bit per pixel
    bih.biClrImportant=0;
    bih.biClrUsed = 0;
    bih.biCompression = BI_RGB;
    bih.biPlanes = 1;
    bih.biSize = 40;
    bih.biXPelsPerMeter = 0;
    bih.biYPelsPerMeter = 0;
    //calculate total size of RGBQUAD scanlines (DWORD aligned)
    bih.biSizeImage = (((bih.biWidth * 3) + 3) & 0xFFFC) * bih.biHeight ;


    pFrame=AVIStreamGetFrameOpen(pStream, NULL);
    //https://www.codeproject.com/Questions/238467/AVIStreamGetFrameOpen-returns-NULL
    //https://www.codeproject.com/Articles/8739/Extracting-AVI-Frames
    //https://www.vbforums.com/showthread.php?293534-Memory-leak-problem-resolved
    //https://www.codeproject.com/Articles/8739/Extracting-AVI-Frames
    //https://stackoverflow.com/questions/39059959/vfw-avistreamgetframeopen-returns-null


    return TRUE;
}


DWORD WINAPI AnimateAVI(LPVOID lpArg) {
  while (TRUE) {
    //https://www.vbforums.com/showthread.php?604246-AVIStreamGetFrameOpen-AVIStreamGetFrameClose-memory-leak
    //https://forum.doom9.org/showthread.php?t=100297
    //https://forums.qhimm.com/index.php?topic=2402.25
    //https://www.codeproject.com/Articles/8739/Extracting-AVI-Frames
    //https://stackoverflow.com/questions/39059959/vfw-avistreamgetframeopen-returns-null
    //ffmpeg -i gameplay_day_crop.mp4 -vcodec cinepak -vf scale=320:240 -r 15 gameplay_day_crop_crt5.avi
    //ffmpeg -i gameplay_day_crop.mp4 -vcodec cinepak -r 15 gameplay_day_crop_crt5_1.avi


    //15 frames = 1000ms
    //1frame = 1000/15 = 66.666666667


    //30 frames = 1000ms
    //1frame = 1000/30 = 33.33333333333
      if (in_main_menu) {
        BYTE* pDIB = (BYTE*) AVIStreamGetFrame(pFrame, global_frames);
        if (global_frames%2!=0) {
          DeleteObject(global_avi_bitmap2);
          global_avi_bitmap2=CreateFromPackedDIBPointer2(pDIB); //set up and draw even
        } else {
          DeleteObject(global_avi_bitmap1);
          global_avi_bitmap1=CreateFromPackedDIBPointer2(pDIB); //set up and draw odd
        }

        global_frames++;
        if (global_frames>=iNumFrames)
          global_frames=0;

        Sleep(33);
      } else {
        Sleep(1000); //standby
      }
  }
}

