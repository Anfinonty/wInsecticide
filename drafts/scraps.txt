//http://www.winprog.org/tutorial/transparency.html
HBITMAP CreateBitmapMask(HDC hdc, HBITMAP hbmColour, COLORREF crTransparent)
{
  HDC hdcMem, hdcMem2;
  HBITMAP hbmMask;
  BITMAP bm;

    // Create monochrome (1 bit) mask bitmap.
  GetObject(hbmColour, sizeof(BITMAP), &bm);
  hbmMask = CreateBitmap(bm.bmWidth, bm.bmHeight, 1, 1, NULL);

    // Get some HDCs that are compatible with the display driver
  hdcMem = CreateCompatibleDC(hdc);
  hdcMem2 = CreateCompatibleDC(hdc);

  SelectObject(hdcMem, hbmColour);
  SelectObject(hdcMem2, hbmMask);

    // Set the background colour of the colour image to the colour
    // you want to be transparent.
  SetBkColor(hdcMem, crTransparent);

    // Copy the bits from the colour image to the B+W mask... everything
    // with the background colour ends up white while everythig else ends up
    // black...Just what we wanted.
  BitBlt(hdcMem2, 0, 0, bm.bmWidth, bm.bmHeight, hdcMem, 0, 0, SRCCOPY);

    // Take our new mask and use it to turn the transparent colour in our
    // original colour image to black so the transparency effect will
    // work right.
  BitBlt(hdcMem, 0, 0, bm.bmWidth, bm.bmHeight, hdcMem2, 0, 0, SRCINVERT);

    // Clean up.
  DeleteDC(hdcMem);
  DeleteDC(hdcMem2);

  return hbmMask;
}

/*
//https://www.codeguru.com/multimedia/rotate-a-bitmap-image/
HBITMAP GetRotatedBitmap(HBITMAP hBitmap, float radians, COLORREF clrBack )
{
	// Create a memory DC compatible with the display
	HDC sourceDC, destDC;
	sourceDC->CreateCompatibleDC( NULL );
	destDC->CreateCompatibleDC( NULL );

	// Get logical coordinates
	BITMAP bm;
	::GetObject( hBitmap, sizeof( bm ), &bm );

	float cosine = (float)cos(radians);
	float sine = (float)sin(radians);

	// Compute dimensions of the resulting bitmap
	// First get the coordinates of the 3 corners other than origin
	int x1 = (int)(-bm.bmHeight * sine);
	int y1 = (int)(bm.bmHeight * cosine);
	int x2 = (int)(bm.bmWidth * cosine - bm.bmHeight * sine);
	int y2 = (int)(bm.bmHeight * cosine + bm.bmWidth * sine);
	int x3 = (int)(bm.bmWidth * cosine);
	int y3 = (int)(bm.bmWidth * sine);

	int minx = min(0,min(x1, min(x2,x3)));
	int miny = min(0,min(y1, min(y2,y3)));
	int maxx = max(x1, max(x2,x3));
	int maxy = max(y1, max(y2,y3));

	int w = maxx - minx;
	int h = maxy - miny;


	// Create a bitmap to hold the result
	HBITMAP hbmResult = ::CreateCompatibleBitmap(CClientDC(NULL), w, h);

	HBITMAP hbmOldSource = (HBITMAP)::SelectObject( sourceDC.m_hDC, hBitmap );
	HBITMAP hbmOldDest = (HBITMAP)::SelectObject( destDC.m_hDC, hbmResult );

	// Draw the background color before we change mapping mode
	HBRUSH hbrBack = CreateSolidBrush( clrBack );
	HBRUSH hbrOld = (HBRUSH)::SelectObject( destDC.m_hDC, hbrBack );
	destDC.PatBlt( 0, 0, w, h, PATCOPY );
	::DeleteObject( ::SelectObject( destDC.m_hDC, hbrOld ) );

	// Set mapping mode so that +ve y axis is upwords
	sourceDC->SetMapMode(MM_ISOTROPIC);
	sourceDC->SetWindowExt(1,1);
	sourceDC->SetViewportExt(1,-1);
	sourceDC->SetViewportOrg(0, bm.bmHeight-1);

	destDC->SetMapMode(MM_ISOTROPIC);
	destDC->SetWindowExt(1,1);
	destDC->SetViewportExt(1,-1);
	destDC->SetWindowOrg(minx, maxy);

	// Now do the actual rotating - a pixel at a time
	// Computing the destination point for each source point
	// will leave a few pixels that do not get covered
	// So we use a reverse transform - e.i. compute the source point
	// for each destination point

	for( int y = miny; y < maxy; y++ )
	{
		for( int x = minx; x < maxx; x++ )
		{
			int sourcex = (int)(x*cosine + y*sine);
			int sourcey = (int)(y*cosine - x*sine);
			if( sourcex >= 0 && sourcex < bm.bmWidth && sourcey >= 0
					&& sourcey < bm.bmHeight )
				destDC.SetPixel(x,y,sourceDC.GetPixel(sourcex,sourcey));
		}
	}

	// Restore DCs
	::SelectObject( sourceDC.m_hDC, hbmOldSource );
	::SelectObject( destDC.m_hDC, hbmOldDest );

	return hbmResult;
}*/


//https://stackoverflow.com/questions/60922844/hbitmap-stretchblt-caused-image-saturation
HBITMAP ResizeBitmap(HDC hdc, HBITMAP source)
{
    HDC hMemDC1,hMemDC2;

    hMemDC2 = CreateCompatibleDC(hdc);
    HGDIOBJ hOld2 = SelectObject(hMemDC2, source);

    BITMAP bitmap = { 0 };
    GetObject(source, sizeof(BITMAP), &bitmap);

    hMemDC1 = CreateCompatibleDC(hdc);
    HBITMAP hBitmap1 = CreateCompatibleBitmap(hdc, bitmap.bmWidth, bitmap.bmHeight);
    HGDIOBJ hOld1 = SelectObject(hMemDC1, hBitmap1);

   //Flips horizontally (x)
    StretchBlt(hMemDC1, bitmap.bmWidth, 0, -bitmap.bmWidth-1, bitmap.bmHeight, hMemDC2, 0,0, bitmap.bmWidth, bitmap.bmHeight, SRCCOPY);

    SelectObject(hMemDC1, hOld1);
    SelectObject(hMemDC2, hOld2);

    DeleteDC(hMemDC1);
    DeleteDC(hMemDC2);

    return hBitmap1;
}

//https://forums.codeguru.com/showthread.php?118153-Flipping-graphics-using-StretchBlt




/*
https://forum.powerbasic.com/forum/user-to-user-discussions/powerbasic-for-windows/47733-basic-image-rotation-iv-plgblt
Function RotateImage(theta As Single, hSrc As Dword, hDest As Dword) As Long
    Dim PlgPts(0 To 2) As PointAPI
    Local XCenter, YCenter As Long
    XCenter = 149 : YCenter = 149
'   newx = XCenter + (x - XCenter) * Cos(theta) - (y - YCenter) * Sin(theta)
'   newy = YCenter + (x - XCenter) * Sin(theta) + (y - YCenter) * Cos(theta)
    PlgPts(0).X = XCenter + (0   - XCenter) * Cos(theta) - (0   - YCenter) * Sin(theta)  'upper-left in target
    PlgPts(0).Y = YCenter + (0   - XCenter) * Sin(theta) + (0   - YCenter) * Cos(theta)
    PlgPts(1).X = XCenter + (299 - XCenter) * Cos(theta) - (0   - YCenter) * Sin(theta)  'upper-right in target
    PlgPts(1).Y = YCenter + (299 - XCenter) * Sin(theta) + (0   - YCenter) * Cos(theta)
    PlgPts(2).X = XCenter + (0   - XCenter) * Cos(theta) - (299 - YCenter) * Sin(theta)  'lower left in target
    PlgPts(2).Y = YCenter + (0   - XCenter) * Sin(theta) + (299 - YCenter) * Cos(theta)
    PlgBlt(hDest, PlgPts(0), hSrc, 0, 0, 300, 300, 0&, 0, 0)  ' Draw rotated image
End Function
*/




//https://www.codeguru.com/multimedia/rotate-a-bitmap-image/
// GetRotatedBitmap	- Create a new bitmap with rotated image
// Returns		- Returns new bitmap with rotated image
// hBitmap		- Bitmap to rotate
// radians		- Angle of rotation in radians
// clrBack		- Color of pixels in the resulting bitmap that do
//			  not get covered by source pixels
// Note			- If the bitmap uses colors not in the system palette 
//			  then the result is unexpected. You can fix this by
//			  adding an argument for the logical palette.
/*HBITMAP GetRotatedBitmap(HDC hdc, HBITMAP hBitmap, float radians, int COLOR )
{
	// Create a memory DC compatible with the display
	HDC sourceDC, destDC;
	sourceDC=CreateCompatibleDC( hdc );
	destDC=CreateCompatibleDC( hdc );

	// Get logical coordinates
	BITMAP bm;
	GetObject( hBitmap, sizeof( bm ), &bm );

	float cosine = (float)cos(radians);
	float sine = (float)sin(radians);

	// Compute dimensions of the resulting bitmap
	// First get the coordinates of the 3 corners other than origin
	int x1 = (int)(-bm.bmHeight * sine);
	int y1 = (int)(bm.bmHeight * cosine);
	int x2 = (int)(bm.bmWidth * cosine - bm.bmHeight * sine);
	int y2 = (int)(bm.bmHeight * cosine + bm.bmWidth * sine);
	int x3 = (int)(bm.bmWidth * cosine);
	int y3 = (int)(bm.bmWidth * sine);

	int minx = min(0,min(x1, min(x2,x3)));
	int miny = min(0,min(y1, min(y2,y3)));
	int maxx = max(x1, max(x2,x3));
	int maxy = max(y1, max(y2,y3));

	int w = maxx - minx;
	int h = maxy - miny;


	// Create a bitmap to hold the result
	HBITMAP hbmResult = CreateCompatibleBitmap(hdc, w, h);

	HBITMAP hbmOldSource = (HBITMAP) SelectObject( sourceDC, hBitmap );
	HBITMAP hbmOldDest = (HBITMAP)  SelectObject( destDC, hbmResult );

	// Draw the background color before we change mapping mode
	HBRUSH hbrBack = CreateSolidBrush(COLOR);
	HBRUSH hbrOld = (HBRUSH) SelectObject( destDC, hbrBack );
	PatBlt(destDC, 0, 0, w, h, PATCOPY );
	DeleteObject( SelectObject( destDC, hbrOld ) );

	// Set mapping mode so that +ve y axis is upwords
	SetMapMode(sourceDC,MM_ISOTROPIC);
	SetWindowExtEx(sourceDC,1,1,0);
	SetViewportExtEx(sourceDC,1,-1,0);
	SetViewportOrgEx(sourceDC,0, bm.bmHeight-1,0);

	SetMapMode(destDC,MM_ISOTROPIC);
	SetWindowExtEx(destDC,1,1,0);
	SetViewportExtEx(destDC,1,-1,0);
	SetWindowOrgEx(destDC,minx, maxy,0);

	// Now do the actual rotating - a pixel at a time
	// Computing the destination point for each source point
	// will leave a few pixels that do not get covered
	// So we use a reverse transform - e.i. compute the source point
	// for each destination point

	for( int y = miny; y < maxy; y++ ) {
	  for( int x = minx; x < maxx; x++ ) {
		int sourcex = (int)(x*cosine + y*sine);
		int sourcey = (int)(y*cosine - x*sine);
		if(sourcex >= 0 && sourcex < bm.bmWidth && sourcey >= 0 && sourcey < bm.bmHeight)
			SetPixel(destDC,x,y,SetPixel(sourceDC,sourcex,sourcey,COLOR));
	  }
	}

	// Restore DCs
	SelectObject( sourceDC, hbmOldSource );
	SelectObject( destDC, hbmOldDest );

	return hbmResult;
}*/



//https://ftp.zx.net.nz/pub/Patches/ftp.microsoft.com/MISC/KB/en-us/77/127.HTM
HBITMAP Rotate90(HDC hDC, HBITMAP hSourceBitmap)
   {
   HBITMAP hOldSourceBitmap, hOldDestBitmap, hDestBitmap;
   HDC hMemSrc, hMemDest;

   int height, width;
   int i, j;

   BITMAP iSrcBitmap;

   // Step 1: Create a memory DC for the source and destination bitmaps
   //         compatible with the device used.

   hMemSrc = CreateCompatibleDC(hDC);
   hMemDest= CreateCompatibleDC(hDC);

  // Step 2: Get the height and width of the source bitmap.

   GetObject(hSourceBitmap, sizeof(BITMAP), (LPSTR)&iSrcBitmap);
   width = iSrcBitmap.bmWidth;
   height = iSrcBitmap.bmHeight;

   // Step 3: Select the source bitmap into the source DC. Create a
   //         destination bitmap, and select it into the destination DC.

   hOldSourceBitmap = SelectObject(hMemSrc, hSourceBitmap);
   hDestBitmap = CreateBitmap(height, width, iSrcBitmap.bmPlanes,
                    iSrcBitmap.bmBitsPixel, NULL);

   if (!hDestBitmap)
     return(hDestBitmap);

   hOldDestBitmap = SelectObject(hMemDest, hDestBitmap);

   // Step 4: Copy the pixels from the source to the destination.

   for (i = 0; i < width; ++i)
       for (j = 0; j < height; ++j)
           SetPixel(hMemDest, j, width - 1 - i,
                                             GetPixel(hMemSrc, i, j));
   // Step 5: Destroy the DCs.

   SelectObject(hMemSrc, hOldSourceBitmap);
   SelectObject(hMemDest, hOldDestBitmap);
   DeleteDC(hMemDest);
   DeleteDC(hMemSrc);

   // Step 6: Return the rotated bitmap.

   return(hDestBitmap);
}





// GetRotatedBitmap	- Create a new bitmap with rotated image
// Returns		- Returns new bitmap with rotated image
// hBitmap		- Bitmap to rotate
// radians		- Angle of rotation in radians
// clrBack		- Color of pixels in the resulting bitmap that do
//			  not get covered by source pixels
// Note			- If the bitmap uses colors not in the system palette 
//			  then the result is unexpected. You can fix this by
//			  adding an argument for the logical palette.
HBITMAP GetRotatedBitmap( HBITMAP hBitmap, float radians, COLORREF clrBack )
{
	// Create a memory DC compatible with the display
	CDC sourceDC, destDC;
	sourceDC.CreateCompatibleDC( NULL );
	destDC.CreateCompatibleDC( NULL );

	// Get logical coordinates
	BITMAP bm;
	::GetObject( hBitmap, sizeof( bm ), &bm );

	float cosine = (float)cos(radians);
	float sine = (float)sin(radians);

	// Compute dimensions of the resulting bitmap
	// First get the coordinates of the 3 corners other than origin
	int x1 = (int)(-bm.bmHeight * sine);
	int y1 = (int)(bm.bmHeight * cosine);
	int x2 = (int)(bm.bmWidth * cosine - bm.bmHeight * sine);
	int y2 = (int)(bm.bmHeight * cosine + bm.bmWidth * sine);
	int x3 = (int)(bm.bmWidth * cosine);
	int y3 = (int)(bm.bmWidth * sine);

	int minx = min(0,min(x1, min(x2,x3)));
	int miny = min(0,min(y1, min(y2,y3)));
	int maxx = max(x1, max(x2,x3));
	int maxy = max(y1, max(y2,y3));

	int w = maxx - minx;
	int h = maxy - miny;


	// Create a bitmap to hold the result
	HBITMAP hbmResult = ::CreateCompatibleBitmap(CClientDC(NULL), w, h);

	HBITMAP hbmOldSource = (HBITMAP)::SelectObject( sourceDC.m_hDC, hBitmap );
	HBITMAP hbmOldDest = (HBITMAP)::SelectObject( destDC.m_hDC, hbmResult );

	// Draw the background color before we change mapping mode
	HBRUSH hbrBack = CreateSolidBrush( clrBack );
	HBRUSH hbrOld = (HBRUSH)::SelectObject( destDC.m_hDC, hbrBack );
	destDC.PatBlt( 0, 0, w, h, PATCOPY );
	::DeleteObject( ::SelectObject( destDC.m_hDC, hbrOld ) );

	// Set mapping mode so that +ve y axis is upwords
	sourceDC.SetMapMode(MM_ISOTROPIC);
	sourceDC.SetWindowExt(1,1);
	sourceDC.SetViewportExt(1,-1);
	sourceDC.SetViewportOrg(0, bm.bmHeight-1);

	destDC.SetMapMode(MM_ISOTROPIC);
	destDC.SetWindowExt(1,1);
	destDC.SetViewportExt(1,-1);
	destDC.SetWindowOrg(minx, maxy);

	// Now do the actual rotating - a pixel at a time
	// Computing the destination point for each source point
	// will leave a few pixels that do not get covered
	// So we use a reverse transform - e.i. compute the source point
	// for each destination point

	for( int y = miny; y < maxy; y++ )
	{
		for( int x = minx; x < maxx; x++ )
		{
			int sourcex = (int)(x*cosine + y*sine);
			int sourcey = (int)(y*cosine - x*sine);
			if( sourcex >= 0 && sourcex < bm.bmWidth && sourcey >= 0
					&& sourcey < bm.bmHeight )
				destDC.SetPixel(x,y,sourceDC.GetPixel(sourcex,sourcey));
		}
	}

	// Restore DCs
	::SelectObject( sourceDC.m_hDC, hbmOldSource );
	::SelectObject( destDC.m_hDC, hbmOldDest );

	return hbmResult;
}





/*
void SetStaticPicture(){
   HBITMAP bmpFrom = (HBITMAP) LoadImage( NULL, "popupbk.bmp", IMAGE_BITMAP, 0, 0,
                      LR_CREATEDIBSECTION | LR_DEFAULTSIZE | LR_LOADFROMFILE );   if( !bmpFrom ) return;
   BITMAP                     bm;
   GetObject( bmpFrom, sizeof(bm), &bm );
   HDC     hdc     = GetDC( hwnd );
   HDC     hdcFrom = CreateCompatibleDC( hdc );
   HDC     hdcTo   = CreateCompatibleDC( hdc );
   HBITMAP bmpTo   = CreateCompatibleBitmap( hdcTo, width, height );
   HGDIOBJ hobFrom = SelectObject( hdcFrom, bmpFrom );
   HGDIOBJ hobTo   = SelectObject( hdcTo, bmpTo );
   StretchBlt( hdcTo,   0, 0, width,      height,               hdcFrom, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY );
   SelectObject( hdcFrom, hobFrom );
   SelectObject( hdcTo, hobTo );
   DeleteObject( bmpFrom );
   ReleaseDC( hwnd, hdc );
   DeleteDC( hdcFrom );
   DeleteDC( hdcTo );
   bkgdImage = bmpTo; // <<<< assuming bkgdImage is a HBITMAP member var here
   SendMessage( hwnd, STM_SETIMAGE, (WPARAM) IMAGE_BITMAP, (LPARAM) bkgdImage );
}*/

//https://www.gamedev.net/forums/topic/583799-win32-load-bitmap-resize-copy-to-static-control/4713803/




//https://ftp.zx.net.nz/pub/Patches/ftp.microsoft.com/MISC/KB/en-us/77/127.HTM
HBITMAP Rotate(HDC hDC, HBITMAP hSourceBitmap, double radians) {
   HBITMAP hOldSourceBitmap, hOldDestBitmap, hDestBitmap;
   HDC hMemSrc, hMemDest;
   BITMAP iSrcBitmap;

   // Step 1: Create a memory DC for the source and destination bitmaps
   //         compatible with the device used.
   hMemSrc = CreateCompatibleDC(hDC);
   hMemDest= CreateCompatibleDC(hDC);

  // Step 2: Get the height and width of the source bitmap.
   GetObject(hSourceBitmap, sizeof(iSrcBitmap), (LPSTR)&iSrcBitmap);

// Get logical coordinates
   double cosine = (double)cos(radians);
   double sine = (double)sin(radians);

	// Compute dimensions of the resulting bitmap
	// First get the coordinates of the 3 corners other than origin
   int x1 = (int)(-iSrcBitmap.bmHeight * sine);
   int y1 = (int)(iSrcBitmap.bmHeight * cosine);
   int x2 = (int)(iSrcBitmap.bmWidth * cosine - iSrcBitmap.bmHeight * sine);
   int y2 = (int)(iSrcBitmap.bmHeight * cosine + iSrcBitmap.bmWidth * sine);
   int x3 = (int)(iSrcBitmap.bmWidth * cosine);
   int y3 = (int)(iSrcBitmap.bmWidth * sine);

   int minx = min(0,min(x1, min(x2,x3)));
   int miny = min(0,min(y1, min(y2,y3)));
   int maxx = max(0,max(x1, max(x2,x3)));
   int maxy = max(0, max(y1, max(y2,y3)));

   int width = maxx - minx;
   int height = maxy - miny;

   // Step 3: Select the source bitmap into the source DC. Create a
   //         destination bitmap, and select it into the destination DC.
   hOldSourceBitmap = SelectObject(hMemSrc, hSourceBitmap);
   //hDestBitmap = CreateBitmap(height, width, iSrcBitmap.bmPlanes, iSrcBitmap.bmBitsPixel, NULL);
   hDestBitmap = CreateCompatibleBitmap(hDC, width, height);   

   if (!hDestBitmap)
     return(hDestBitmap);

   hOldDestBitmap = SelectObject(hMemDest, hDestBitmap);


	// Draw the background color before we change mapping mode
    COLORREF clrBack = RGB(255,255,255); //For transparent background
	HBRUSH hbrBack = CreateSolidBrush( clrBack );
	HBRUSH hbrOld = (HBRUSH) SelectObject( hMemDest, hbrBack );
	PatBlt(hMemDest, 0, 0, width, height, PATCOPY );
	DeleteObject( SelectObject(hMemDest, hbrOld ) );


	// Set mapping mode so that +ve y axis is upwords
	SetMapMode(hMemSrc, MM_ISOTROPIC);
	SetWindowExtEx(hMemSrc, 1,1,NULL);
	SetViewportExtEx(hMemSrc, 1,-1,NULL);
	SetViewportOrgEx(hMemSrc, 0, iSrcBitmap.bmHeight-1,NULL);

	SetMapMode(hMemDest, MM_ISOTROPIC);
	SetWindowExtEx(hMemDest, 1,1,NULL);
	SetViewportExtEx(hMemDest, 1,-1,NULL);
	SetWindowOrgEx(hMemDest, minx, maxy,NULL);



   // Step 4: Copy the pixels from the source to the destination.
   for (int y=miny;y<maxy;y++) {
	 for(int x=minx;x<maxx;x++) {
	   int sourcex = (int)(x*cosine+y*sine);
	   int sourcey = (int)(y*cosine-x*sine);
	   if(sourcex>=0 && sourcex<iSrcBitmap.bmWidth && sourcey>=0
	   	   && sourcey<iSrcBitmap.bmHeight )
	     SetPixel(hMemDest, x, y, GetPixel(hMemSrc,sourcex,sourcey));
	  }
	}

   // Step 5: Destroy the DCs.
   SelectObject(hMemSrc, hOldSourceBitmap);
   SelectObject(hMemDest, hOldDestBitmap);
   DeleteDC(hMemDest);
   DeleteDC(hMemSrc);

   // Step 6: Return the rotated bitmap.
   return(hDestBitmap);
}






bool _Sleep(int msec) {
  current_time=GetTickCount();
  long long time_diff=current_time-saved_time;
  if (time_diff>=msec) { //if timediff is above 6 millisecs,
    saved_time=current_time; 
    return true;
  }
  //if timediff is less than 6 millisecs
  //Sleep(1);
  YieldProcessor();
  return false;
}

void delay(unsigned int mseconds)
{
    clock_t goal = mseconds + clock();
    while (goal > clock())
      YieldProcessor();
}


//https://learn.microsoft.com/en-us/windows/win32/sysinfo/acquiring-high-resolution-time-stamps?redirectedfrom=MSDN
/*
LARGE_INTEGER StartingTime, EndingTime, ElapsedMicroseconds;
LARGE_INTEGER Frequency;

QueryPerformanceFrequency(&Frequency); 
QueryPerformanceCounter(&StartingTime);

// Activity to be timed
//for (int t=0;t<65536;t++);
PlayerAct();
delay(1);

QueryPerformanceCounter(&EndingTime);
ElapsedMicroseconds.QuadPart = EndingTime.QuadPart - StartingTime.QuadPart;

ElapsedMicroseconds.QuadPart *= 1000000;
ElapsedMicroseconds.QuadPart /= Frequency.QuadPart;
printf("EMS: %d\n",ElapsedMicroseconds.QuadPart);*/

//https://learncgames.com/using-small-delays-in-c-with-sdl-ticks/







/*int machinespeed() {
  struct timeval time_start,time_now;
  int tick,i,j,c=2048,d=5;
  double sum=0,sum2=0;
  for (j=0;j<d;j++) { //5 times & generate avg
    for (i=0;i<c;i++) { //count to 65546 2048 times & generate avg
      mingw_gettimeofday(&time_start, NULL); //get time in msec
      for (tick=0;tick<65536;tick++);
      mingw_gettimeofday(&time_now, NULL); //get time in msec after for count
      sum += (time_now.tv_sec - time_start.tv_sec) * 1000000 + time_now.tv_usec - time_start.tv_usec;
    }
    sum2+=sum/c;
    sum=0;
  }
  return (int) sum2/d; //return machine speed
}*/

/*int machinespeed() {
  int tick=0;
  long long start_time=current_timestamp();
  long long current_time=LLONG_MAX;

  long long time_diff;
  while (true) {
    time_diff=current_time-start_time;
    if (time_diff<100) {
      current_time=current_timestamp();
      tick++;
    } else {
      return tick/100;
    }
  }
}*/

